module yvertx.test;

import org.vertx.java.deploy:Container;
import org.vertx.java.core.file:FileProps;

load yvertx;

load yvertx.cb;

load yvertx.testutils;

httpc = load yvertx.httpc;
https = load yvertx.https;




fileDir = "../../target/yeti-test-output";


verticle do {container, vertx}:
    println "running tests";
    fs = fileSystem vertx;
    fshelper = {
        clean dir after = 
            fs.exists dir (noex do exi:
                if exi then
                    fs.delete dir true (noex \(
                        fs.mkdir dir none true (noex after)
                    ))
                else
                    fs.mkdir dir none true (noex after)
                fi
            done);
        
    };

    httpMethod opts method rstu =
        (rstu.setTimeout 5000;
        server = https.create vertx;
        var ssl = false;
        var chunked = false;
        for opts \case of
            SSL b: ssl := b;
            Chunked b: chunked := b;
            esac;

        if ssl then
            server#setSSL(true)
                #setKeyStorePassword("wibble")
                #setKeyStorePath("keystores/server-keystore.jks")
                #setTrustStorePath("keystores/server-truststore.jks")
                #setTrustStorePassword("wibble")
                #setClientAuthRequired(true)
        fi;
        
        path = "/someurl/blah.html";
        query = "param1=vparam1&param2)vparam2";
        uri = if ssl then "https" else "http" fi
                  ^ "://localhost:8080" ^ path ^"?"^query;
        headers = ["header1":"vheader1",
                   "header2":"vheader2"];
        rheaders = ["rheader1":"vrheader1",
                   "rheader2":"vrheader"];
        
        _ = https.requestHandler server do req:
            rstu.assert "" (uri == req#uri);
            rstu.assert "" (method == req#method);
            rstu.assert "" (path == req#path);
            rstu.assert "" (query == req#query);

            rstu.assert "" (https.headers req == headers);
            rstu.assert "" (https.params req == ["param1":"vparam1",
                                                 "param2":"vparam2"]);
                                                
            https.putHeaders req rheaders; 
            
            body = newBuffer 0;

            https.dataHandler req do data:
                _ = body#appendBuffer(data);
            done;

            req#response#setChunked(chunked);

            https.endHandler req do:
                if not chunked then
                    https.putHeaders req 
                        ["Content-Length":string body#length()];
                fi;
                req#response#writeBuffer(body);
                if chunked then
                    https.putTrailers req ["trailer1" : "vtrailer1",
                                           "trailer2" : "vtrailer2"];
                fi;
            done;
        done;

        server#listen(8080);

        client = httpc.create vertx "localhost:8080";

        if ssl then
            client#setSSL(true)
                #setKeyStorePath("keystores/client-keystore.jks")
                #setKeyStorePassword("wibble")
                #setTrustStorePath("keystores/client-truststore.jks")
                #setTrustStorePassword("wibble");
        fi;

        sentBuff = generateRandomBuffer(1000);

        request = httpc.generalRequest client method uri headers do resp:
            rstu.assert "" (200 == resp#statusCode);
            rstu.assert "" (httpc.headers resp == rheaders);
            body = newBuffer(0);
            httpc.dataHandler resp do data:
                _ = body#appendBuffer(data);
            done;

            httpc.endHandler resp do:
                rstu.assert "" (buffersEqual sentBuff body);
                if chunked then
                    rstu.assert "" (httpc.trailers resp ==
                                    ["trailer1":"vtrailer1",
                                    "trailer2":"vtrailer2"]);
                fi;
                https.close server do:
                    rstu.assure "" true;
                done;
            done;
        done;

        _ = request#setChunked(chunked);
        if not chunked then
            httpc.putHeaders request 
                ["Content-Length": string sentBuff#length()];
        fi;
        _ = request#writeBuffer(sentBuff);
        request#end());
            
    runTests vertx container [

"common load": do rs:
   // rs.assure "" ("foo" == load yvertx.common.module1);
   rs.assure "" true;
done,

"deploy" : do rs:
    bus.register vertx "test-handler"
        \(_ = deployVerticle 
                container 
                "yvertx.deploy.child.yeti" emptyJS 1 
                \())
        do {body,handler}:
        println "in body \(body.started)";
        if body.started then
            println "in body";
            rs.assure "in body" true;
            bus.unregister vertx "test-handler" handler \();
        else
            println "wrong message"
        fi
        done;
done,

"undeploy" : do rs:
    _ = deployVerticle container "yvertx.deploy.child.yeti" emptyJS 1
        do did:
            bus.register vertx "test-handler" \() do {body,handler}:
                if body.stopped then
                    rs.assure "body-stopped" true;
                    bus.unregister vertx "test-handler" handler \();
                fi
            done;
            undeployVerticle container did \();
        done;
done,

"cb:Id" : do rs:
   (cbId 2) do v: rs.assure "" (2 == v) done;
done,

"cb:Bind" : do rs:
    (do cb: cb 1 done) 
    ->> do x: 
        rs.assert "" (x == 1);
        do cb: cb "hier" done;
        done
        $do v:
            rs.assure "" (v == "hier")
        done
done,

"cb:flatten" : do rs:
    (cbFlatten (cbId (cbId 1))) do v: rs.assure "" (v == 1) done;
done,

"cb:lift" : do rs:
    ((cbLift do x: string x done) 1) do st:
        rs.assure "" (st == "1")
    done;
done,

"cb:Seq" : do rs:
    //make services 
    adresses = [1..10] |> map (("adr"^) . string);
    for adresses do adr:
        bus.register vertx adr \() do {reply, handler}:
            reply {value = 1};
            bus.unregister vertx adr handler \();
        done
    done;
    handlers = adresses |> map do adr:
        bus.request vertx adr emptyJS -> 
            do {body} : body.value done
    done;
    cbSeq handlers do res:
        rs.assure "\(res)" true //(10 == fold (+) 0 res);
    done
done,

"cb:Col" : do rs:
    register adr =
        bus.register vertx adr \() do {reply, handler} :
            reply {value = adr ^ "foo"};
            bus.unregister vertx adr handler \();
        done;
    
    for [1..2] (register . ("adr"^) . string);

    cbCol \{
         a = cbSet
            (bus.requestBody vertx "adr1" emptyJS -> (.value)),
         b = cbSet
            (bus.requestBody vertx "adr2" emptyJS -> (.value)),
        }
        do r :
            rs.assure "\(r)" (r.a() == "adr1foo" 
                              and r.b() == "adr2foo");
        done;
done,




"eventbus:simple" : do rs:
    msg = {address = "foo-address", price=23.45};
    rs.setTimeout(2000);
    address = "foo-some";
    var handled = false;
    bus.register vertx address \() do {body, handler}:
        bus.unregister vertx address handler \();
        rs.assure "\(body)" (body == msg and not handled);
        handled := true;
    done;
    bus.send vertx address msg;
done,

"eventbus:emptyMessage" : do rs:
    var handled = false;
    adr = "foo";
    msg = emptyJS;
    bus.register vertx adr \() do {body,handler}:
        bus.unregister vertx adr handler \();
        rs.assure "\(body)" (body == msg and not handled);
        handled := true;
    done;
    bus.send vertx adr msg;
done,

"eventbus:unregister" : do rs:
    var handled = false;
    msg = {count = 1, foo = "foo"};
    var assertion = true;
    bus.register vertx "foo" \() do {body,handler}:
        assertion := assertion and (body == msg and not handled);
        bus.unregister vertx "foo" handler \();
        //should do nothing
        bus.unregister vertx "foo" handler \();
        handled := true;
        setTimer vertx 100 do:
            //complete the test
            rs.assure "" assertion;
        done;
    done;
    for [1..3] \(bus.send vertx "foo" msg);
done,

"eventbus:withReply" : do rs:
    var handled = false;
    msg = {count=1, foo = "foo2"};
    repl = {reply = true};
    var asserts = true;
    bus.register vertx "foo" \() do {body,handler, reply}:
        asserts := asserts and (not handled and msg == body);
        bus.unregister vertx "foo" handler \();
        handled := true;
        reply repl;
    done;

    bus.request vertx "foo" msg do {body}:
        rs.assure "\(body)" (asserts and (body == repl));
    done;
done,

"eventbus:replyOfReplyOfReply" : do rs:
    adr = "foo";
    msg = {msg = "message"};
    repl = {msg = "repl"};
    repl2 = {msg = "repl2"};
    repl3 = {msg = "repl3"};
    bus.register vertx adr \() do {body, handler, request}:
        rs.assert "" (msg == body);
        request repl do {body, reply}:
            rs.assert "" (repl2 == body);
            reply repl3;
            bus.unregister vertx adr handler \();
        done
    done;

    bus.request vertx adr msg do {body,request}:
        rs.assert "" (body == repl);
        request repl2 do {body}:
            rs.assure "" (body == repl3);
        done
    done;
done,

"eventbus:emptyReply" : do rs:
    var handled = false;
    adr = "foo";
    msg = emptyJS;
    bus.register vertx adr \() do {reply, body, handler}:
        rs.assert "" (not handled);
        rs.assert "" (msg == body);
        bus.unregister vertx adr handler \();
        handled := true;
        reply emptyJS;
    done;
    bus.request vertx adr msg do {body, reply}:
        rs.assure "" true;
    done;
done,

"filesystem:copy" : do rs:
    dir = fileDir^"/copy";
    fshelper.clean dir \(;
    from = dir ^"/foo.tmp";
    to = dir ^"/bar.tmp";
    content = "some-data";
    fs.writeFile from (newStringBuffer content) (noex do:
        fs.copy from to true (noex do:
            fs.readFile to (noex do res:
                rs.assure "" ((string res) == content)
            done);
        done)
    done));
done,

"filesystem:move" : do rs:
    fshelper.clean fileDir \(;
    from = fileDir ^"/foo.tmp";
    to = fileDir ^"/bar.tmp";
    content = "some-data";
    fs.writeFile from (newStringBuffer content) (noex do:
        fs.move from to (noex do:
            fs.readFile to (noex do res:
                rs.assure "" ((string res) == content)
            done)
        done)
    done))
done,    

"filesystem:readDir" : do rs:
    dir = fileDir ^ "/readdir";
    fshelper.clean dir \(
        file1 = dir ^"/foo.tmp";
        file2 = dir ^"/bar.tmp";
        file3 = dir ^"/baz.tmp";
        content = newStringBuffer "some-data";
        fs.writeFile file1 content (noex do:
            fs.writeFile file2 content (noex do:
                fs.writeFile file3 content (noex do:
                    fs.readDir dir none (noex do res:
                        rs.assert "\(res)" (length res == 3);
                    done)
                done)
            done)
        done)
    );
done,

"filesystem:props" : do rs:
    dir = fileDir ^ "/props";
    fshelper.clean dir \(
        content = newStringBuffer "some-data";
        file = dir ^"/foo.tmp";
        fs.writeFile file content (noex do:
            fs.props file (noex do res:
                rs.assert "" (res is ~FileProps)#isRegularFile;
                rs.assert "" (res#creationTime#getTime() > 0);
                rs.assert "" (res#lastAccessTime#getTime() > 0);
                rs.assure "" (res#lastModifiedTime#getTime() > 0);
            done)
        done)
    );
done,

"filesystem:pumpFile" : do tests:
    import org.vertx.java.core.file:AsyncFile;
    dir = fileDir^"/pumpfile";
    fshelper.clean dir \(
        from = dir^"/foo.tmp";
        to = dir^"/bar.tmp";
        content = generateRandomBuffer(10000);
        fs.writeFile from content (noex do:
            fs.open [] from (noex do file1:
                fs.open [] to (noex do file2:
                    rs = (file1 is ~AsyncFile)#getReadStream();
                    ws = (file2 is ~AsyncFile)#getWriteStream();
                    pump = createPump rs ws;
                    pump#start();
                    rs#endHandler(toHandler do:
                        file1#close(toAsyncResultHandler (noex do:
                            file2#close(toAsyncResultHandler (noex do:
                                fs.readFile to (noex do res:
                                    tests.assert "" (buffersEqual content res);
                                done);
                            done));
                        done));
                    done);
                done);
            done);
        done);
    )
done,

"http:get" : httpMethod [] "GET",

"http:put" : httpMethod [] "PUT",

"http:post" : httpMethod [] "POST",

"http:head" : httpMethod [] "HEAD",

"http:options" : httpMethod [] "OPTIONS",

"http:delete" : httpMethod [] "DELETE",

"http:trace" : httpMethod [] "TRACE",

"http:connect" : httpMethod [] "CONNECT",

"http:path" : httpMethod [] "PATCH",


];
    \()
done;

