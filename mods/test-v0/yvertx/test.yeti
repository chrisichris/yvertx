module yvertx.test;

import org.vertx.java.deploy:Container;
import org.vertx.java.core.file:FileProps;

load yvertx;

load yvertx.cb;

load yvertx.testutils;

httpc = load yvertx.httpc;
https = load yvertx.https;
webs = load yvertx.websocket;



fileDir = "../../target/yeti-test-output";


verticle do {container, vertx}:
    fs = fileSystem vertx;
    fshelper = {
        clean dir after = 
            fs.exists dir (noex do exi:
                if exi then
                    fs.delete dir true (noex \(
                        fs.mkdir dir none true (noex after)
                    ))
                else
                    fs.mkdir dir none true (noex after)
                fi
            done);
        
    };

    httpMethod opts method variant rstu =
        (rstu.setTimeout 15000;
        var ssl = false;
        var chunked = false;
        for opts \case of
            SSL b: ssl := b;
            Chunked b: chunked := b;
            esac;

        path = "/someurl/blah.html";
        query = "param1=vparam1&param2=vparam2";
        
        uri = if ssl then "https" else "http" fi
                  ^ "://localhost:8080" ^ path ^"?"^query;
        headers = ["header1":"vheader1",
                   "header2":"vheader2"];
        rheaders = ["rheader1":"vrheader1",
                   "rheader2":"vrheader"];
        
        server = https.createWithHandler vertx do req:
            rstu.assert "uri \(req#uri)" (uri == req#uri);
            rstu.assert "method" (method == req#method);
            rstu.assert "path" (path == req#path);
            rstu.assert "query" (query == req#query);

            rstu.assert "headers" 
                (fold (flip ((and) . (in (https.headers req))))
                    true (keys headers));
            rstu.assert "params" (https.params req == ["param1":"vparam1",
                                                 "param2":"vparam2"]);
                                                
            https.putHeaders req rheaders; 
            
            body = newBuffer 0;

            https.dataHandler req do data:
                _ = body#appendBuffer(data);
            done;

            req#response#setChunked(chunked);

            https.endHandler req do:
                if not chunked then
                    https.putHeaders req 
                        ["Content-Length":string body#length()];
                fi;
                req#response#writeBuffer(body);
                if chunked then
                    https.putTrailers req ["trailer1" : "vtrailer1",
                                           "trailer2" : "vtrailer2"];
                fi;
                req#response#end();
            done;
        done;

        if ssl then
            server#setSSL(true)
                #setKeyStorePassword("wibble")
                #setKeyStorePath("keystores/server-keystore.jks")
                #setTrustStorePath("keystores/server-truststore.jks")
                #setTrustStorePassword("wibble")
                #setClientAuthRequired(true)
        fi;

        _ = server#listen(8080);

        //wait for server to be ready
        _ = setTimer vertx 1000 do:

            sentBuff = generateRandomBuffer(1000);
            
            
            client = httpc.create vertx "localhost:8080";

            request = httpc.request client (variant uri) headers
            do resp:

                rstu.assert "statusCode" (200 == resp#statusCode);
                rstu.assert "rHeaders: \(httpc.headers resp) | \(rheaders)" 
                        (fold (flip ((and) . (in (httpc.headers resp))))
                            true (keys rheaders) );
                body = newBuffer(0);
                httpc.dataHandler resp do data:
                    _ = body#appendBuffer(data);
                done;

                httpc.endHandler resp do:
                    rstu.assert "sentBuff" (buffersEqual sentBuff body);
                    if chunked then
                        rstu.assert "rTrailers" (httpc.trailers resp ==
                                        ["trailer1":"vtrailer1",
                                        "trailer2":"vtrailer2"]);
                    fi;
                    https.close server do:
                        rstu.assure "" true;
                    done;
                done;
            done;
            if ssl then
                client#setSSL(true)
                    #setKeyStorePath("keystores/client-keystore.jks")
                    #setKeyStorePassword("wibble")
                    #setTrustStorePath("keystores/client-truststore.jks")
                    #setTrustStorePassword("wibble");
            fi;

            _ = request#setChunked(chunked);
            if not chunked then
                httpc.putHeaders request 
                    ["Content-Length": string sentBuff#length()];
            fi;
            _ = request#writeBuffer(sentBuff);
            request#end();
        done);

    websocketEcho binary rs =        
        (rs.setTimeout 1000;
      
        server = https.create vertx;

        webs.serverHandler server do ws:
            webs.dataHandler ws do buff:
                _ = ws#writeBuffer(buff);
            done;
        done;
        server#listen(8080);

        
        _ = setTimer vertx 1000 do:
            client = httpc.create vertx "localhost:8080";
            
            {buff,str} = if binary then
                    {buff = generateRandomBuffer 1000, str = ""};
                else
                    str = randomUnicodeString(1000);
                    {buff = newStringBuffer str, str};
                fi;

            webs.clientHandler client "/someurl" do ws:
                received = newBuffer 0;
                webs.dataHandler ws do data:
                    _ = received#appendBuffer(data);
                    if received#length() == buff#length() then
                        rs.assert "be" (buffersEqual received buff);
                        client#close();
                        https.close server do:
                            rs.assure "finished" true;
                        done;
                    fi;
                    if binary then
                        ws#writeBinaryFrame(buff);
                    else
                        ws#writeTextFrame(str);
                    fi
                done;
            done
        done);
        


    runTests vertx container [

"common load": do rs:
   // rs.assure "" ("foo" == load yvertx.common.module1);
   rs.assure "" true;
done,

"deploy" : do rs:
    bus.register vertx "test-handler"
        \(_ = deployVerticle 
                container 
                "yvertx.deploy.child.yeti" emptyJS 1 
                \())
        do {body,handler}:
        if body.started then
            rs.assure "in body" true;
            bus.unregister vertx "test-handler" handler \();
        else
        fi
        done;
done,

"undeploy" : do rs:
    _ = deployVerticle container "yvertx.deploy.child.yeti" emptyJS 1
        do did:
            bus.register vertx "test-handler" \() do {body,handler}:
                if body.stopped then
                    rs.assure "body-stopped" true;
                    bus.unregister vertx "test-handler" handler \();
                fi
            done;
            undeployVerticle container did \();
        done;
done,

"cb:Id" : do rs:
   (cbId 2) do v: rs.assure "" (2 == v) done;
done,

"cb:Bind" : do rs:
    (do cb: cb 1 done) 
    ->> do x: 
        rs.assert "" (x == 1);
        do cb: cb "hier" done;
        done
        $do v:
            rs.assure "" (v == "hier")
        done
done,

"cb:flatten" : do rs:
    (cbFlatten (cbId (cbId 1))) do v: rs.assure "" (v == 1) done;
done,

"cb:lift" : do rs:
    ((cbLift do x: string x done) 1) do st:
        rs.assure "" (st == "1")
    done;
done,

"cb:Seq" : do rs:
    //make services 
    adresses = [1..10] |> map (("adr"^) . string);
    for adresses do adr:
        bus.register vertx adr \() do {reply, handler}:
            reply {value = 1};
            bus.unregister vertx adr handler \();
        done
    done;
    handlers = adresses |> map do adr:
        bus.request vertx adr emptyJS -> 
            do {body} : body.value done
    done;
    cbSeq handlers do res:
        rs.assure "\(res)" true //(10 == fold (+) 0 res);
    done
done,

"cb:Col" : do rs:
    register adr =
        bus.register vertx adr \() do {reply, handler} :
            reply {value = adr ^ "foo"};
            bus.unregister vertx adr handler \();
        done;
    
    for [1..2] (register . ("adr"^) . string);

    cbCol \{
         a = cbSet
            (bus.requestBody vertx "adr1" emptyJS -> (.value)),
         b = cbSet
            (bus.requestBody vertx "adr2" emptyJS -> (.value)),
        }
        do r :
            rs.assure "\(r)" (r.a() == "adr1foo" 
                              and r.b() == "adr2foo");
        done;
done,




"eventbus:simple" : do rs:
    msg = {address = "foo-address", price=23.45};
    rs.setTimeout(2000);
    address = "foo-some";
    var handled = false;
    bus.register vertx address \() do {body, handler}:
        bus.unregister vertx address handler \();
        rs.assure "\(body)" (body == msg and not handled);
        handled := true;
    done;
    bus.send vertx address msg;
done,

"eventbus:emptyMessage" : do rs:
    var handled = false;
    adr = "foo";
    msg = emptyJS;
    bus.register vertx adr \() do {body,handler}:
        bus.unregister vertx adr handler \();
        rs.assure "\(body)" (body == msg and not handled);
        handled := true;
    done;
    bus.send vertx adr msg;
done,

"eventbus:unregister" : do rs:
    var handled = false;
    msg = {count = 1, foo = "foo"};
    var assertion = true;
    bus.register vertx "foo" \() do {body,handler}:
        assertion := assertion and (body == msg and not handled);
        bus.unregister vertx "foo" handler \();
        //should do nothing
        bus.unregister vertx "foo" handler \();
        handled := true;
        _ = setTimer vertx 100 do:
            //complete the test
            rs.assure "" assertion;
        done;
    done;
    for [1..3] \(bus.send vertx "foo" msg);
done,

"eventbus:withReply" : do rs:
    var handled = false;
    msg = {count=1, foo = "foo2"};
    repl = {reply = true};
    var asserts = true;
    bus.register vertx "foo" \() do {body,handler, reply}:
        asserts := asserts and (not handled and msg == body);
        bus.unregister vertx "foo" handler \();
        handled := true;
        reply repl;
    done;

    bus.request vertx "foo" msg do {body}:
        rs.assure "\(body)" (asserts and (body == repl));
    done;
done,

"eventbus:replyOfReplyOfReply" : do rs:
    adr = "foo";
    msg = {msg = "message"};
    repl = {msg = "repl"};
    repl2 = {msg = "repl2"};
    repl3 = {msg = "repl3"};
    bus.register vertx adr \() do {body, handler, request}:
        rs.assert "" (msg == body);
        request repl do {body, reply}:
            rs.assert "" (repl2 == body);
            reply repl3;
            bus.unregister vertx adr handler \();
        done
    done;

    bus.request vertx adr msg do {body,request}:
        rs.assert "" (body == repl);
        request repl2 do {body}:
            rs.assure "" (body == repl3);
        done
    done;
done,

"eventbus:emptyReply" : do rs:
    var handled = false;
    adr = "foo";
    msg = emptyJS;
    bus.register vertx adr \() do {reply, body, handler}:
        rs.assert "" (not handled);
        rs.assert "" (msg == body);
        bus.unregister vertx adr handler \();
        handled := true;
        reply emptyJS;
    done;
    bus.request vertx adr msg do {body, reply}:
        rs.assure "" true;
    done;
done,

"filesystem:copy" : do rs:
    dir = fileDir^"/copy";
    fshelper.clean dir \(;
    from = dir ^"/foo.tmp";
    to = dir ^"/bar.tmp";
    content = "some-data";
    fs.writeFile from (newStringBuffer content) (noex do:
        fs.copy from to true (noex do:
            fs.readFile to (noex do res:
                rs.assure "" ((string res) == content)
            done);
        done)
    done));
done,

"filesystem:move" : do rs:
    fshelper.clean fileDir \(;
    from = fileDir ^"/foo.tmp";
    to = fileDir ^"/bar.tmp";
    content = "some-data";
    fs.writeFile from (newStringBuffer content) (noex do:
        fs.move from to (noex do:
            fs.readFile to (noex do res:
                rs.assure "" ((string res) == content)
            done)
        done)
    done))
done,    

"filesystem:readDir" : do rs:
    dir = fileDir ^ "/readdir";
    fshelper.clean dir \(
        file1 = dir ^"/foo.tmp";
        file2 = dir ^"/bar.tmp";
        file3 = dir ^"/baz.tmp";
        content = newStringBuffer "some-data";
        fs.writeFile file1 content (noex do:
            fs.writeFile file2 content (noex do:
                fs.writeFile file3 content (noex do:
                    fs.readDir dir none (noex do res:
                        rs.assert "\(res)" (length res == 3);
                    done)
                done)
            done)
        done)
    );
done,

"filesystem:props" : do rs:
    dir = fileDir ^ "/props";
    fshelper.clean dir \(
        content = newStringBuffer "some-data";
        file = dir ^"/foo.tmp";
        fs.writeFile file content (noex do:
            fs.props file (noex do res:
                rs.assert "" (res is ~FileProps)#isRegularFile;
                rs.assert "" (res#creationTime#getTime() > 0);
                rs.assert "" (res#lastAccessTime#getTime() > 0);
                rs.assure "" (res#lastModifiedTime#getTime() > 0);
            done)
        done)
    );
done,

"filesystem:pumpFile" : do tests:
    import org.vertx.java.core.file:AsyncFile;
    dir = fileDir^"/pumpfile";
    fshelper.clean dir \(
        from = dir^"/foo.tmp";
        to = dir^"/bar.tmp";
        content = generateRandomBuffer(10000);
        fs.writeFile from content (noex do:
            fs.open [] from (noex do file1:
                fs.open [] to (noex do file2:
                    rs = (file1 is ~AsyncFile)#getReadStream();
                    ws = (file2 is ~AsyncFile)#getWriteStream();
                    pump = createPump rs ws;
                    pump#start();
                    rs#endHandler(toHandler do:
                        file1#close(toAsyncResultHandler (noex do:
                            file2#close(toAsyncResultHandler (noex do:
                                fs.readFile to (noex do res:
                                    tests.assert "" (buffersEqual content res);
                                done);
                            done));
                        done));
                    done);
                done);
            done);
        done);
    )
done,

"http:hostport" : do rs:
    {host,port} = helper.hostAndPort "localhost:8080";
    rs.assure "" (host == "localhost" and port == 8080);
done,

"http:clientserver" : do rs:
    import java.lang:Thread;
    rs.setTimeout(15000);
    server = (https.createWithHandler vertx do req:
        (https.putHeaders req 
            ["Content-Type": "text/html; charset=UTF-8"]);
        req#response#end(
            "<html><body><h1>Hello from vert.x!</h1></body></html>");
    done);
    server#listen(8080);

    _ = setTimer vertx 1000 do:
        client = httpc.create vertx "localhost:8080";
        httpc.getBodyNow
            client
            "/" 
            [:] 
            do {resp, buffer}:
                https.close server do:
                    rs.assure (string buffer) true;
                done;
            done;
    done;
done,
    

"http:get" : httpMethod [] "GET" Get,

"http:put" : httpMethod [] "PUT" Put,

"http:post" : httpMethod [] "POST" Post,

"http:head" : httpMethod [] "HEAD" Head,

"http:options" : httpMethod [] "OPTIONS" Options,

"http:delete" : httpMethod [] "DELETE" Delete,

"http:trace" : httpMethod [] "TRACE" Trace,

"http:connect" : httpMethod [] "CONNECT" Connect,

"http:path" : httpMethod [] "PATCH" Patch,

"net:test1" : do rs:
    net = load yvertx.net;
    server = net.createServerWithHandler vertx do sock:
        net.dataHandler sock do buffer:
            _ = sock#write(buffer);
        done;
    done;

    server#listen(1234,"localhost");

    serverCloseFn _ = net.closeServer server \(rs.assure "closed" true);

    client = net.createClient vertx;

    net.connectClient client "localhost:1234" serverCloseFn
        do sock:
            net.dataHandler sock do buffer:
                net.closeClient client;
                serverCloseFn();
            done;
            _ = sock#write(newStringBuffer "this is a buffer");
        done;
done,

"parsetools:delimited" : do rs:
    recordparser = load yvertx.recordparser;
    var lineCount = 0;
    
    parser = recordparser.delimited "\n" do buffer:
        lineCount := lineCount + 1;
        if lineCount == 3 then
            rs.assure "" true;
        fi
    done;

    parser (newStringBuffer "asfdasfsafafafa\nauio\nasdfa\n");
done,

"parsetools:fixed" : do rs:
    recordparser = load yvertx.recordparser;
    var chunkCount = 0;
    chunkSize = 100;
    numChunks = 3;

    parser = recordparser.fixed chunkSize do buffer:
        rs.assert "" (chunkSize == buffer#length());
        chunkCount = chunkCount + 1;
        if chunkCount == numChunks then
            rs.assure "" true;
        fi;
    done;

    input = newBuffer 0;
    for [1..numChunks] do:
        _ = input#appendBuffer(generateRandomBuffer chunkSize);
    done;
    parser input;
done,

"timer:oneOff" : do rs:
    rs.setTimeout 5000;

    var count = 0;
    _ = setTimer vertx 1000 do tid:
        rs.assert "count" (count == 0);
        count := count + 1;
        _ = setTimer vertx 10 do:
            rs.assure "" true
        done;
    done;
done,

"timer:periodic" : do rs:
    rs.setTimeout 5000;
    numFires = 20;
    delay = 100;
    var count = 0;
    _ = setPeriodic vertx delay do timerId:
        count := count + 1;
        if count == numFires then
            _ = cancelTimer vertx timerId;
            _ = setTimer vertx 10 do:
                rs.assure "" true;
            done;
        fi;
        if count > numFires then
            rs.assert "Fired too many times" false;
        fi
    done;
done,

"websocket:echoBinary" : websocketEcho true,

"websocket:echoString" : websocketEcho false,

"websocket:writeFromConnectionHandler" : do rs:
    rs.setTimeout 5000;
    server = https.create vertx;
    webs.serverHandler server do ws:
        _ = ws#writeTextFrame("foo");
    done;
    server#listen(8080);

    _ = setTimer vertx 1000 do:
        client = httpc.create vertx "localhost:8080";
        webs.clientHandler client "/someurl" do ws:
            webs.dataHandler ws do buff:
                rs.assert "" ("foo" == string buff);
                client#close();
                https.close server do:
                    rs.assure "close" true;
                done;
            done
        done;
    done;
done,

"websocket:close" : do rs:
    rs.setTimeout 5000;
    server = https.create vertx;
    webs.serverHandler server do ws:
        webs.dataHandler ws do:
            ws#close();
        done;
    done;
    server#listen(8080);

    _ = setTimer vertx 1000 do:
        client = httpc.create vertx "localhost:8080";
        webs.clientHandler client "/someurl" do ws:
            webs.closedHandler ws do:
                client#close();
                https.close server do:
                    rs.assure "close" true;
                done;
                ws#writeTextFrame("foo");
            done;
        done;
    done
done,

"websocket:closeFromConnectionHandler" : do rs:
    rs.setTimeout 5000;
    server = https.create vertx;
    webs.serverHandler server do ws :
        ws#close();
    done;
    server#listen(8080);

    _ = setTimer vertx 1000 do:
        client = httpc.create vertx "localhost:8080";
        webs.clientHandler client "/someurl" do ws:
            webs.closedHandler ws do:
                client#close();
                https.close server do:
                    rs.assure "close" true;
                done;
            done;
        done;
    done
done,

];
    \()
done;

