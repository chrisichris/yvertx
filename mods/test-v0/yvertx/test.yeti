module yvertx.test;

import org.vertx.java.deploy:Container;

load yvertx;


verticle do {container, vertx}:
    println "running tests";
    fs = fileSystem vertx;
    fileDir = "yeti-test-ouput";
    runTests vertx container [

"common load": do rs:
   // rs.assure "" ("foo" == load yvertx.common.module1);
   rs.assure "" true;
done,

"deploy" : do rs:
    bus.register vertx "test-handler"
        \(_ = deployVerticle container "yvertx.deploy.child.yeti" emptyJS 1 
            \())
        do {body,handler}:
        println "in body \(body.started)";
        if body.started then
            println "in body";
            rs.assure "in body" true;
            bus.unregister vertx "test-handler" handler \();
        else
            println "wrong message"
        fi
        done;
done,

"undeploy" : do rs:
    _ = deployVerticle container "yvertx.deploy.child.yeti" emptyJS 1
        do did:
            bus.register vertx "test-handler" \() do {body,handler}:
                if body.stopped then
                    rs.assure "body-stopped" true;
                    bus.unregister vertx "test-handler" handler \();
                fi
            done;
            undeployVerticle container did \();
        done;
done,

"eventbus:simple" : do rs:
    msg = {address = "foo-address", price=23.45};
    rs.setTimeout(2000);
    address = "foo-some";
    var handled = false;
    bus.register vertx address \() do {body, handler}:
        bus.unregister vertx address handler \();
        rs.assure "\(body)" (body == msg and not handled);
        handled := true;
    done;
    bus.send vertx address msg \();
done,

"eventbus:emptyMessage" : do rs:
    var handled = false;
    adr = "foo";
    msg = emptyJS;
    bus.register vertx adr \() do {body,handler}:
        bus.unregister vertx adr handler \();
        rs.assure "\(body)" (body == msg and not handled);
        handled := true;
    done;
    bus.send vertx adr msg \();
done,

"eventbus:unregister" : do rs:
    var handled = false;
    msg = {count = 1, foo = "foo"};
    var assertion = true;
    bus.register vertx "foo" \() do {body,handler}:
        assertion := assertion and (body == msg and not handled);
        bus.unregister vertx "foo" handler \();
        //should do nothing
        bus.unregister vertx "foo" handler \();
        handled := true;
        setTimer vertx 100 do:
            //complete the test
            rs.assure "" assertion;
        done;
    done;
    for [1..3] \(bus.send vertx "foo" msg \());
done,

"eventbus:withReply" : do rs:
    var handled = false;
    msg = {count=1, foo = "foo2"};
    repl = {reply = true};
    var asserts = true;
    bus.register vertx "foo" \() do {body,handler, reply}:
        asserts := asserts and (not handled and msg == body);
        bus.unregister vertx "foo" handler \();
        handled := true;
        reply repl;
    done;

    bus.send vertx "foo" msg do {body}:
        rs.assure "\(body)" (asserts and (body == repl));
    done;
done,

"eventbus:replyOfReplyOfReply" : do rs:
    adr = "foo";
    msg = {msg = "message"};
    repl = {msg = "repl"};
    repl2 = {msg = "repl2"};
    repl3 = {msg = "repl3"};
    bus.register vertx adr \() do {body, handler, replyWithHandler}:
        rs.assert "" (msg == body);
        replyWithHandler repl do {body, reply}:
            rs.assert "" (repl2 == body);
            reply repl3;
            bus.unregister vertx adr handler \();
        done
    done;

    bus.send vertx adr msg do {body, replyWithHandler}:
        rs.assert "" (body == repl);
        replyWithHandler repl2 do {body}:
            rs.assure "" (body == repl3);
        done
    done;
done,

"eventbus:emptyReply" : do rs:
    var handled = false;
    adr = "foo";
    msg = emptyJS;
    bus.register vertx adr \() do {reply, body, handler}:
        rs.assert "" (not handled);
        rs.assert "" (msg == body);
        bus.unregister vertx adr handler \();
        handled := true;
        reply emptyJS;
    done;

    bus.send vertx adr msg do {body, reply}:
        rs.assure "" true;
    done;
done,

];
    \()
done;

