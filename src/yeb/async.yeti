/*
 * Copyright 2011 Christian Essl
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 */

module yeb.async;

import java.lang:Exception,
                RuntimException;

//callback functions
typedef either<a> = None ~Exception | Some a; 
typedef callback<a> = either<a> -> ();
typedef asyncFunction<a> = callback<a> -> ();

/**
 * Group: async (ASYNC)
 * Transforms a value in an asyncFunction
 *
 * Arguments:
 *  value - value to which the created function will pass in the reciever
 */
returnEither v is either<'a> -> asyncFunction<'a> = 
    do cb: cb v done;

/**
 * Group: async (ASYNC)
 * Transforms a value in an asyncFunction which always return some. Same as
 * return (Some v)
 *
 * Arguments:
 *  value - value to which the created function will pass in the reciever
 */
return v is 'a -> asyncFunction<'a> =
    returnEither (Some v);

class AsyncException(String msg) extends RuntimeException
end;


/**
 * Group: async
 * crates a None with Excpetion
 */
failNone msg = 
    (import yeti.lang:FailureException;
    (None ((new FailureException(msg is string)) as ~Exception)));

/**
 * Group: async 
 * creates an AsyncException from a string
 */
returnNone msg = returnEither (failNone msg);

/**
 * Group: async
 * Joins two asyncFunctions in sequenc, where the second function
 * is dependent on the result of the first.
 *
 * see also the (->) operator for a shorthand and exmples 
 *
 * Arguments:
 * mappingFunction - is given the value of the first asyncFunction and should
 * returns the second callback funcion
 * asyncFunction - the first callback function in the sequence
 */
bindEither fn cbfn
    is  (either<'a> -> asyncFunction<'b>) 
        -> asyncFunction<'a> -> asyncFunction<'b> =
    do cb:
        cbfn do a:
                afn = try
                        fn a
                    catch Exception ex:
                        returnEither (None ex);
                    yrt;
                afn cb;
             done;
    done;

/**
 * Group: async
 * Joins two asyncFunctions in sequenc with the value, where the second function
 * is dependent on the result of the first.
 *
 * Differnt to bind the second function only gets the value of a positit Some
 * result of the callback. If there is a failure this is given further.
 *
 * see also the (->>) operator for a shorthand and exmples 
 *
 * Arguments:
 * mappingFunction - is given the value of the first asyncFunction and should
 * returns the second callback funcion
 * asyncFunction - the first callback function in the sequence
 */
bind fn cbfn
    is  ('a -> asyncFunction<'b>) 
        -> asyncFunction<'a> -> asyncFunction<'b> =
    cbfn |> bindEither \case of
        None msg: returnEither (None msg);
        Some a: fn a;
        esac;


/**
 * Group: async
 * Handles failure in an async functiond and returns a new one.
 *
 * Differnt to bind the second function only gets the failure. If the callback
 * receives a falid value it is passed further.
 *
 * see also the (-|>) operator for a shorthand and exmples 
 *
 * Arguments:
 * mappingFunction - is given the value of the first asyncFunction and should
 * returns the second callback funcion
 * asyncFunction - the first callback function in the sequence
 */
bindNone fn cbfn
    is  ( ~Exception -> asyncFunction<'b>) 
        -> asyncFunction<'a> -> asyncFunction<'b> =
    cbfn |> bindEither \case of
        None ex: fn ex;
        Some a: return a;
        esac;

/**
 * Group: async
 * Executes a sequence of asyncFunctions in parallel and calls the callback 
 * with either a list of results or the first exception which occured
 *
 * Arguments:
 * asycnFunctions - the list of asyncFunctions to execute
 * callback - the callbac function which gets called with the result
 */
parallel cbfns cb 
    is list?<asyncFunction<'a>> -> callback<list<'a>> -> () =
    (res = array [];
    var handled = false;
    for cbfns do c:
        try
        c do r:
            finished = synchronized res \case r of
                None str: 
                    if not handled then
                        handled := true;
                        Some (None str);
                    else
                        none
                    fi;
                Some a:
                    if not handled then
                        push res a;
                        if length res == length cbfns then
                            handled := true;
                            Some (Some(list res));
                        else
                            none
                        fi
                    else
                        none
                    fi
                esac;
            case finished of
                None _ : ();
                Some arg : cb arg;
            esac;
        done;
        catch Exception ex:
            cb (None ex);
        yrt;
    done);


/**
 * Group: async
 * Only used inside a function given to 'cbColllect'. Executes the given
 * asyncFunction and returns a function containin the value
 *
 * For an example see cbCollect
 *
 * Arguments:
 * asyncFunction - the asyncFunction from which to take the value
 */
setAsync ctr cbfn is 'b -> asyncFunction<'a> -> (() -> 'a) =
    (ctr.starting();
    mutex = ctr.mutex;
    var hasReceived = false;
    var res = NotSet ();
    cbfn do r:
        call? = synchronized mutex \case r of
            None ex: 
                if not hasReceived then
                    res := Exception (ex is ~Exception);
                    hasReceived := true;
                    Some (None ex);
                else
                    none
                fi;
            Some a:
                if not hasReceived then
                    hasReceived := true;
                    res := Some a;
                    Some (Some ());
                else
                    none
                fi;
            esac;
        case call? of
        None _: ();
        Some arg: ctr.hasReceived arg;
        esac;
    done;
    \(case res of
        NotSet (): failWith "Not set";
        Exception ex: throw (ex is ~Exception);
        Some v: v
      esac));    

/**
 * Group: async
 * Used to collect the results asyncFunctions which get executed in parrallel.
 *
 * Arguments:
 * prepareFunction - function to setup the asyncFunctions to execute
 * callback - callback which receives the result of the prepare function
 * or the exception of the first not succesful result
 *
 */
collectAsync inex cb is ('b -> 'a) -> asyncFunction<'a>=
    (mutex = new Object();
     var called = false;
     var requests = 0;
     var received = 0;
     var result = none;
     ctr = {
        mutex,
        starting () = 
            synchronized mutex \(requests := requests + 1),

        hasReceived ex =
            (call? = synchronized mutex \case ex of
                None str :
                    called := true;
                    Some (None str);
                Some _ :
                    received := received + 1;
                    if not called then
                        case result of
                        None _ : none;
                        Some v: 
                            if received == requests then
                                called := true;
                                Some (Some v);
                            else
                                none
                            fi;
                        esac;
                    else
                        none
                    fi;
                esac;

            case call? of
            None _ : ();
            Some arg: cb arg
            esac),
    };
    try 
        r = inex ctr;
        call? = synchronized mutex 
            \(result := Some r;
            if not called and received == requests then
                called := true;
                Some (Some r);
            else 
                none
            fi);
        case call? of
        None _ : ();
        Some arg: cb arg;
        esac;
            
    catch Exception ex:
        call? = synchronized mutex 
            \(if not called then
                called := true;
                Some (None ex);
            else
                none
            fi);
        case call? of 
        None _: ();
        Some arg: cb arg;
        esac;
    yrt;
    ());

run stru = (stru.f1 ()) \();


/**
 * Group: async
 * blocks for the given time in ms on the asnyc function and returns the
 * result or throws an exception.
 *
 * If the asyncFunction sends a None ~Exception. The exception is thrown.
 * If the timeout is 0 or negative blocks for ever
 */
await timeoutMs asyncFn is number -> asyncFunction<'a> -> 'a =
    (import java.lang.RuntimeException;
    import java.util.concurrent:CountDownLatch,
                                 TimeUnit;
    import org.vertx.java.core.impl:VertxInternal;
    import org.vertx.java.deploy.impl:VertxLocator;

    latch = new CountDownLatch(1);
    avalue = atomic (failNone "notset");

    //run the async function in it's own context otherwise
    //it will never be called because the latch will block
    _ = ((VertxLocator#vertx) unsafely_as ~VertxInternal)
            #startInBackground(runnable do:
        asyncFn do v:
            avalue.value := v;
            latch#countDown();
        done;
    done);

    if timeoutMs < 1 then
        latch#await();
    elif not latch#await(timeoutMs,TimeUnit#MILLISECONDS) then
        failWith "timeout"
    fi;
    case avalue.value of
    None ex: throw (ex is ~Exception);
    Some v: v;
    esac);

{
    //callback functions
    failNone,
    return,
    returnEither,
    returnNone,
    bind,
    bindEither,
    bindNone,
    parallel,
    setAsync,
    collectAsync,
    await,
}
