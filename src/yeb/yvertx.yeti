/*
 * Copyright 2011 Christian Essl
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 */

module yeb.yvertx;

import java.lang:Exception,
                 Runnable,
                 Long;
import java.util:Map;

import org.vertx.java.core:Handler,
                           AsyncResult,
                           AsyncResultHandler,
                           Vertx;
import org.vertx.java.core.impl:Context,
                                VertxInternal;
import org.vertx.java.core.buffer:Buffer;
import org.vertx.java.core.eventbus:Message;
import org.vertx.java.core.file:FileSystem,
                                FileSystemProps,
                                FileProps,
                                AsyncFile;
import org.vertx.java.core.http:HttpClientRequest,
                                HttpClientResponse,
                                HttpClient,
                                HttpServer,
                                HttpServerRequest,
                                HttpServerResponse,
                                WebSocket,
                                ServerWebSocket;
import org.vertx.java.core.json:JsonObject,
                                JsonArray;
import org.vertx.java.core.net:NetClient,
                               NetServer,
                               NetSocket;
import org.vertx.java.core.parsetools:RecordParser;
import org.vertx.java.core.sockjs:SockJSSocket,
                                  SockJSServer;
import org.vertx.java.core.streams:Pump,
                                   ReadStream,
                                   WriteStream;
import org.vertx.java.platform:Verticle,
                             Container;



load yeb.async;

yvf = load yeb.yvertx.vertxholder;

typedef jsonStruct<a> = {.for_json is a};

/**
 * Group: async (ASYNC)
 * blocks for the given time in ms on the asnyc function and returns the
 * result or throws an exception.
 *
 * If the asyncFunction sends a None ~Exception. The exception is thrown.
 * If the timeout is 0 or negative blocks for ever
 */
await timeoutMs asyncFn is number -> asyncFunction<'a> -> 'a =
    (import java.lang.RuntimeException;
    import java.util.concurrent:CountDownLatch,
                                 TimeUnit;
    import org.vertx.java.core.impl:VertxInternal;

    latch = new CountDownLatch(1);
    avalue = atomic (failNone "notset");

    //run the async function in it's own context otherwise
    //it will never be called because the latch will block
    _ = ((yvf.vertx) unsafely_as ~VertxInternal)
            #startInBackground(runnable do:
        asyncFn do v:
            avalue.value := v;
            latch#countDown();
        done;
    done,false);

    if timeoutMs < 1 then
        latch#await();
    elif not latch#await(timeoutMs,TimeUnit#MILLISECONDS) then
        failWith "timeout"
    fi;
    case avalue.value of
    None ex: throw (ex is ~Exception);
    Some v: v;
    esac);

/**
 * Group: json (JSON)
 * Empty json element (should repsenet an empty struct as this is not
 * possible in yeti
 */
emptyJS is jsonStruct<E()>= {for_json = E()};


_toJson object = 
   (import yeti.lang:Num, FloatNum, RatNum,AList, ByKey, Struct, Tag;
    import java.util:ArrayList,Map, HashMap;
  
    nullTag ob = 
        (o = ob as ~Object;
        if o instanceof Tag then
            t = o unsafely_as ~Tag;
            t#name == "E" and nullptr? t#value;
        else
            false
        fi);

        
    o = object as ~Object;
    if nullptr? o then
        o
    elif same? o (emptyJS as ~Object) then
        new JsonObject()
    elif nullTag o then
        () as ~Object;
    elif (o instanceof FloatNum) 
         or (o instanceof RatNum) then
        (o unsafely_as ~Num)#toBigDecimal();
    elif (o instanceof Num) then
        (o unsafely_as ~Num)#toBigInteger();
    elif o instanceof AList then
        jl = new JsonArray();
        for (o unsafely_as list<'a>) do v:
            if not nullTag v then
                _ = jl#add(_toJson v);
            fi;
        done;
        jl as ~Object;
    elif o instanceof ByKey then
        dbo = new HashMap();
        i = (o unsafely_as ~Map)#entrySet()#iterator();
        i#hasNext() loop
            (e = i#next() unsafely_as ~java.util.Map$Entry;
             key = string (e#getKey());
             v = e#getValue();
             if not nullTag v then
                 _ = dbo#put(key, _toJson (v unsafely_as 'a));
             fi);
        new JsonObject(dbo);
    elif o instanceof Struct then
        st = o unsafely_as ~Struct;
        dbo = new HashMap();
        for [0 .. st#count() - 1] do i:
            name = st#name(i);
            v = st#get(i);
            if not nullTag v then
                _ = dbo#put(name, _toJson (v unsafely_as 'a));
            fi;
        done;
        new JsonObject(dbo);
    elif o instanceof Tag then
        t = o unsafely_as ~Tag;
        if t#name == "Some" then
            _toJson (t#value unsafely_as 'a);
        elif t#name == "None" then
            () as ~Object;
        else
            dbo = new HashMap();;
            _ = dbo#put("_vtype",t#name);
            _ = dbo#put(t#name, _toJson (t#value unsafely_as 'a));
            new JsonObject(dbo);
        fi
    else
        o
    fi);

/**
 * Group: json
 * Transforms a yeti struct to a ~JsonObject. 
 * 
 * Each struct must have the field json. If the value of the field is
 * E() than it is not serialized.
 *
 * The filed-types of the struct maybe:
 * - number - becomes either a bigdecimal or a biginteger
 * - string - becomes a string
 * - boolean - becomes a Boolean
 * - None x - becomes null x is ignored
 * - Some x - becomes the value of x, where x must be one of the allowed values
 * - null - becomes null
 * - list?<x> - becomes JsonArray. Note the remmarks for empty lists
 * - struct<x> - another struct which must have the same form as this
 * - hash<x,y> - the key is transfered to a string the value must be one of
 *   this types
 * - E() - means that the value and filed is not included in struct and hash
 *   or list
 *
 * As empty lists [] in yeti are represtend as null it is necessary to give in
 * [E()] if there must be an empty list instead of a null in the corresponding
 * json. 
 *
 * If a certain field should be excluded give it the value N().
 *
 * Arguments:
 * struct - structure to transform to JsonObject
 *
 * Exceptions:
 * java.lang.RuntimeException - if the given argument is no struct
 */
toJson stru is jsonStruct<'a> -> ~JsonObject =
    _toJson stru unsafely_as ~JsonObject;

/**
 * Group: json
 * Transforms yeti list to a JsonArray. The elements can be any values
 * supported by json
 *
 * Arguments:
 * ls - the list to transform
 */
toJsonArray ls is list?<'a> -> ~JsonArray =
   (ar = new JsonArray();
    for ls do e:
        _ = ar#add(_toJson e)
    done;
    ar);
    
_fromJsonToStruct object = 
   (import java.util:List,HashMap,Map;
    import java.lang:Number;
    import yeb:HashStruct;
    import yeti.lang:Tag;
    
    o = object as ~Object;
    
    if nullptr? o then
         o;
    elif o instanceof Number then
       (import java.lang: Double, Float,Number;
        import java.math: BigInteger, BigDecimal;
        import yeti.lang:Num,BigNum,IntNum,FloatNum;
        if (o instanceof Double) or
             (o instanceof Float) or
             (o instanceof BigDecimal)
             then
                nu = o unsafely_as ~Number;
                new FloatNum(nu#doubleValue());
        elif o instanceof BigInteger then
            nu = o unsafely_as ~BigInteger;
            new BigNum(nu);
        elif o instanceof Num then
            o unsafely_as ~Num;
        else
            nu = o unsafely_as ~Number;
            new IntNum(nu#longValue());
        fi)
    elif o instanceof JsonArray then
        it = (o unsafely_as ~JsonArray)#iterator();
        ar = array [];
        (it#hasNext()) loop push ar (_fromJsonToStruct it#next());
        (list ar) as ~Object;
    elif o instanceof JsonObject then
        jo = o unsafely_as ~JsonObject;
        //check for variant
        if defined? jo#getString("_vtype",undef_str) 
            and defined? jo#getField("value") then
            new Tag(_fromJsonToStruct jo#getField("value"), 
                    jo#getString("_vtype"))
        else
            ma = new HashMap();
            i = jo#toMap()#entrySet()#iterator();
            i#hasNext() loop
               (e = i#next() unsafely_as ~java.util.Map$Entry;
                value = _fromJsonToStruct (e#getValue() unsafely_as 'a);
                if not nullptr? value then
                    ma#put(string e#getKey(), value);
                fi);
            new HashStruct(ma);
        fi;
    elif o instanceof Buffer then
        ((o unsafely_as ~Buffer)#getBytes()) as ~Object;
    else
        o
    fi);

typedef yvertxJsonValue<a> = {
    str is string,
    num is number,
    bool is boolean,
    arr is list<yvertxJsonValue>,
    obj is hash<string,yvertxJsonValue>,
    bytes is ~byte[],
    someStr is None () | Some string,
    someBool is None () | Some boolean,
    someNum is None () | Some number,
    someBytes is None () | Some ~byte[],
    type is number,
    jsonStruct is a
};

_jsonPrototype = {
    get str () = failWith "No json string value",
    get num () = failWith "No json num value",
    get bool () = failWith "No json boolean",
    get arr () = failWith "No json list",
    get obj () = failWith "No json obj",
    get bytes () = failWith "No bytes",
    get someStr () = none,
    get someBool () = none,
    get someNum () = none,
    get someBytes () = none,
    get jsonStruct () = failWith "No json obj",
    get type () = 0
};

_fromJsonValue o is ~Object -> yvertxJsonValue<'a>= 
   (import java.util:List,HashMap,Map;
    import java.lang:Number;
    import yeb:HashStruct;
    import yeti.lang:Tag;
    
    
    if nullptr? o or not defined? o then
         _jsonPrototype;
    elif o instanceof JsonObject then
        jo = o unsafely_as ~JsonObject;
        ha = [:];
        setHashDefault ha do k:
            obj = jo#getField(k is string);
            _fromJsonValue obj;
        done;
        _jsonPrototype with {
            obj = ha,
            get jsonStruct () = (_fromJsonToStruct o) unsafely_as 'a, 
            type = 1,
        }
    elif o instanceof JsonArray then
        it = (o unsafely_as ~JsonArray)#iterator();
        ar = array [];
        (it#hasNext()) loop push ar (_fromJsonValue it#next());
        ls = (list ar);
        _jsonPrototype with {
            list = ls,
            type = 2 
        }
    elif o instanceof String then
        s = string o;
        _jsonPrototype with {
            str = s,
            someStr = Some s,
            type = 3,
        }
    elif o instanceof Boolean then
        s = (o unsafely_as ~Boolean)#booleanValue();
        _jsonPrototype with {
            bool = s,
            someBool = Some s,
            type = 4
        }
    elif o instanceof Number then
        import java.lang: Double, Float,Number;
        import java.math: BigInteger, BigDecimal;
        import yeti.lang:Num,BigNum,IntNum,FloatNum;
        nu = if (o instanceof Double) or
             (o instanceof Float) or
             (o instanceof BigDecimal)
             then
                nu = o unsafely_as ~Number;
                new FloatNum(nu#doubleValue());
        elif o instanceof BigInteger then
            nu = o unsafely_as ~BigInteger;
            new BigNum(nu);
        elif o instanceof Num then
            o unsafely_as ~Num;
        else
            nu = o unsafely_as ~Number;
            new IntNum(nu#longValue());
        fi;
        numi = (nu unsafely_as number);
        _jsonPrototype with {
            num = numi,
            someNum = Some numi,
            type = 5
        }
    elif o instanceof Buffer then
        b = (o unsafely_as ~Buffer)#getBytes();
        _jsonPrototype with {
            bytes = b,
            someBytes = Some b,
            type = 6
        }
    else 
        failWith "value not supported \(o)";

    fi);

/**
 * Group: json
 * Transforms a JsonObject to a struct. The result will always be a 
 * polymorphic value which represents the JsonObject as struct. So no
 * typechecking is performed on the result but it can be used as a struct.
 *
 * Arguments:
 * jsonObject - the object to transfer 
 */
fromJson object is ~JsonObject -> 'a =
    _fromJsonValue object;

/**
 * Group: json
 * Transrom a JsonArray to a yeti list. The result will alwys be a
 * polymphric value which represnte the JsonObject. So no typechecking is
 * preformed on the values of the list
 *
 * Arguments:
 * jsonArray - the JsonArray object to transfer
 */
fromJsonArray ar is ~JsonArray -> list<'a> =
    (_fromJsonValue ar).arr;    

_blend vin1 vin2 is 'a -> 'b -> 'c=
    (import yeti.lang:Struct,
                      GenericStruct;
    import java.util.HashMap;

    o1 = (vin1 is 'a) unsafely_as ~Object;
    o2 = (vin2 is 'b) unsafely_as ~Object;
    if defined? o1 and defined? o2 and 
       o1 instanceof Struct and o2 instanceof Struct then

        s1 = o1 unsafely_as ~Struct;
        s2 = o2 unsafely_as ~Struct;
        jmap = new HashMap();
        for [0..(s1#count() - 1)] do i:
            na = s1#name(i);
            va = s1#get(i);
            _ = jmap#put(na,va);
        done;
        for [0..(s2#count() - 1)] do i:
            na = s1#name(i);
            va = s1#get(i);
            ov = jmap#get(na);
            va2 = if defined? ov 
                    and (ov unsafely_as ~Object) instanceof Struct then
                    _blend (ov unsafely_as 'a) (va unsafely_as 'b)
                  else 
                      va;
                  fi;
            _ = jmap#put(na,va2);
        done;
        (new GenericStruct(jmap)) unsafely_as 'c;
    else
        o1 unsafely_as 'c;
    fi);

/**
 * Group: json
 * Replaces in the struct the fiels of v1 with the fields of v2 if presten.
 * Works only on struct arguments if either argument is not a struct then
 * the first argument is returen.
 *
 * This is useful when transforming getting a Json struct fom "fromJson" and
 * prefilling it with default values
 *
 * Arguments:
 * v1 - the strcut which is the basis
 * v2 - the strcut which replaces in v1
 *
 * Examples:
 * :defaultV = {ssl=true, port=8080}
 * :withDefaults = blend defaultV (toJson someJsonObject);
 */
blend v1 v2 is 'a -> 'b -> 'c =
    (blend v1 v2) unsafely_as 'c;


/**
 * Group: helper (UTIL)
 * Splits a string of the format "hostname:port" in it's host and port parts.
 * if there is : the whole name is considered the hostname and the port is by
 * default 80. If the string starts with : than the hostname is default
 * localhost and the port is the rest of the sting. If the string is empty
 * the localhost:80 is assumed.
 *
 * Arguments:
 * hostPort - string of format "hostname:port"
 */
hostAndPort hostPort =
   (if not defined? hostPort or hostPort == "" then
        {port = 80, host = "localhost"};
    else
        i = strIndexOf hostPort ":" 0;
        if i < 0 then 
            {port = 80, host = hostPort}
        elif i == 0 then
            {host = "localhost", port = int (number (strRight hostPort 1))}
        else
           {host = strLeft hostPort i,
            port = int (number (strRight hostPort (i+1)))}
        fi
    fi);

/**
 * Group: toHandler (TO_HANDLER)
 * new vertx Handler from function
 * 
 * Arguments:
 * fn - the handler function
 *
 * Examples:
 * :handler = toHandler do ob: 
 * :     buffer = ob unsafely_as ~Buffer;
 * :     ...
 * :done;
 * :(req is ~HttpServerRequest)#bodyHandler(handler);
 */
toHandler fn is (~Object -> ()) -> ~Handler = 
   (class IYetiHandler extends Handler
        void handle(Object ob)
            fn ob,
    end;
    new IYetiHandler());

/** 
 * Group: toHandler
 * A handler wich gets no value takes 
 *
 * Arguments:
 * handler - handler function is () -> ()
 */
toSimpleHandler fn =
    toHandler (fn . \());

/**
 * Group: toHandler
 * creates a handler for long values and transforms them to a yeti number
 *
 * Arguments:
 * handler - function taking a number argument
 */
toLongHandler fn =
    toHandler do ob: fn (ob unsafely_as ~Long)#longValue() done;
        
/**
 * Group: toHandler
 * Creates an AsyncResultHandler. If the asyncResult has an Exception
 * than the function is called with Exception exception, otherwise with
 * Some value.
 *
 * Arguments:
 * handler - funciton taking either Exception ex or Value v
 */
toAsyncResultHandler fn 
    is (either<~Object> -> ()) -> ~AsyncResultHandler =
       (class IYetiAsyncResultHandler extends AsyncResultHandler
            void handle(Object o)
                r = o unsafely_as ~AsyncResult;
                if (r is ~AsyncResult)#succeeded() then
                    fn (Some r#result)
                else
                    fn (None r#exception);
                fi,
        end;
        new IYetiAsyncResultHandler());

/**
 * Group: toHanlder
 * Typed version of AsyncResultHandler
 *
 * Arguments:
 * castFunction - types the value if there is one
 * handlerFucntion - either gets the value (casted by castFunction) or
 * Exception ex
 */
toTypedAsyncResultHandler tfn fn 
    is (~Object -> 'a) -> (either<'a> -> ()) -> ~AsyncResultHandler =
       (class IYetiAsyncResultHandler extends AsyncResultHandler
            void handle(Object o)
                r = o unsafely_as ~AsyncResult;
                if (r is ~AsyncResult)#succeeded() then
                   fn (Some (tfn r#result))
                else
                   fn (None r#exception);
                fi,
        end;
        new IYetiAsyncResultHandler());

/**
 * Group: toHandler
 * Creates a handler for ~Buffer class
 */
toBufferHandler fn =
        toHandler (fn . (unsafely_as ~Buffer));


/**
 * Group: toHandler
 * Creates a handler for ~Exceptions
 */
toExceptionHandler fn =
        toHandler (fn . (unsafely_as ~Exception));

/**
 * Group: toHandler
 * Creates a Handler for ~String
 */
toStringHandler fn =
        toHandler (fn . (as string) .(unsafely_as ~String));

/**
 * Group: stream (STREAM)
 * Adds a dataHandler to a ~ReadStream
 *
 * Arguments:
 * stream - the stream to add the handler
 * handlerFunction - the function which takes a buffer
 */
dataHandler rs handler =
    (rs is ~ReadStream)#dataHandler(toBufferHandler handler);

/**
 * Group: stream
 * Adds an endHandler to a ~ReadStream
 *
 * Arguments:
 * stream - the stream to add the handler
 * handlerFunction - the function which gets called on end
 */
endHandler rs handler =
    (rs is ~ReadStream)#endHandler(toSimpleHandler handler);

/**
 * Group: stream
 * Adds an exceptionHandler to a ~ReadStream
 *
 * Arguments:
 * stream - the stream to add the handler
 * handlerFunction - the function which gets called on exception
 */
exceptionHandler rs handler =
    (rs is ~ReadStream)#exceptionHandler(toExceptionHandler handler);

/**
 * Group: stream
 * Adds a drainHandler to a ~WriteStream
 *
 * Arguments:
 * stream - the stream to add the handler
 * handlerFunction - the function which gets called on drain of the writeStream
 */
drainHandler ws handler =
    (ws is ~WriteStream)#drainHandler(toSimpleHandler handler);

/**
 * Group: stream
 * Adds an exceptionHandler to a ~WriteStream
 *
 * Arguments:
 * stream - the stream to add the handler
 * handlerFunction - the function which gets called on exception
 */
wsExceptionHandler ws handler =
    (ws is ~WriteStream)#exceptionHandler(toExceptionHandler handler);

/**
 * Group: vertx
 * Gets the vertx instance stored in the vertxholder module.
 */
getVertx () = yvf.vertx;

/**
 * Group: container
 * Gets the Container instance stored in the vertxholder module
 */
getContainer () = yvf.container;

/**
 * Group: vertx (VERTX)
 * Put the handler on the event queue for this loop so it will be run 
 * asynchronously ASAP after this event has been processed
 *
 * Same as Vertx#runOnLoop
 *
 * Arguments:
 * handler - function to run on one of the nex ticks
 */
runOnLoop handler = 
    (getVertx ())#runOnLoop(toSimpleHandler handler);

/**
 * Group: vertx
 * Set a periodic timer to fire every delay milliseconds, at which point 
 * handler will be called with the id of the timer.
 *
 * returns the timer-id.
 *
 * Just calls Vertx#setPeriodic
 *
 * Arguments:
 * delay - timer delay in milliseconds
 * handler - handler to call each dellay
 */
setPeriodic  delay handler = 
    (getVertx ())#setPeriodic(delay, 
        toLongHandler handler);
/**
 * Group: vertx
 * Set a one-shot timer to fire after delay milliseconds, at which point
 * handler will be called with the id of the timer.
 * 
 * returns the timer-id. 
 *
 * Just calls Vertx#setTimer
 *
 * Arguments:
 * delay - time in millis
 * handler - handler called after time is given the timer-id
 */
setTimer delay handler =
    (getVertx ())#setTimer(delay, 
        toLongHandler handler);
/**
 * Group: vertx
 * Cancels the timer for the given id
 *
 * Calls Vertx#cancelTimer
 *
 * Arguments:
 * timerid - the id of the timer
 */
cancelTimer timerId =
    (getVertx ())#cancelTimer(timerId);

/**
 * gets the current running context or NULL (undefined)
 */
_currentContext () =
    (vertx = (getVertx()) unsafely_as ~VertxInternal;
    vertx#getContext());
    

/**
 * Group: experimental (EXPERIMENTAL)
 *
 * Creates a new worker wich runs on differnt thread from
 * current thread. Its closed hooks will be called when the close hooks
 * of the creating verticle are called.
 *
 * Similar to a worker verticle but run with a function.
 *
 * Note that the startfn will run on a different worker-thread. So it is not 
 * save without synhroinzation to use objects from the enclosing socpe.
 *
 * Arguments:
 * cb - callback called when succesful created on. Called on the calling 
 * context
 * startfn - function run first on the worker thread. 
 */ 
newWorker startfn cb=     
    (vertx = (getVertx()) unsafely_as ~VertxInternal;
    ctxt = _currentContext();
    if not defined? ctxt then
        failWith "no vertx context defined can not execute";
    fi;

    idw = new Object();

    newCtxt = vertx#startInBackground(runnable do:
        r = try 
            startfn();
            Some "ok";
        catch Exception ex:
            None ex;
        yrt;
        ctxt#execute(runnable \((cb is (either<string> -> ())) r));
        done,false);
    ctxt#putCloseHook(idw, runnable \newCtxt#runCloseHooks()));

/**
 * Group: experimental 
 *
 * Creates a fibre. A firbre is used to send messages between workers and the 
 * parent. It is similar to an eventbus but withonly one address 
 * the fibire itself and abitrary values can be sent.
 *
 * The fibre is thread save and thus can be shared between different contexts.
 */
newFibre () = 
    (import org.vertx.java.core.impl:Context;

    mutex = new Object();
    var listeners = [];
    var curListeners = [];
    {
        /**
         * register a function which gets called when a value is 
         * send/published. Returns a function which is used in unregister
         */
        register fn = 
            ctxt = _currentContext();
            if not defined? ctxt then
                failWith "There is not vertx context"
            fi;
            runfn v = ctxt#execute(runnable \(fn v));
            runob = runfn as ~Object;

            ctxt#putCloseHook(runob, runnable \(unregister runob));  
            synchronized mutex \(listeners := runfn :: listeners);
            runob,
        /**
         * unrgiester a function
         * use the reruned value of register as argument
         */
        unregister ob = 
            synchronized mutex do:
                listeners := listeners 
                |> filter ((same? (ob as ~Object)) . (as ~Object)) 
                |> array
                |> list;
                curListeners := [];
            done,
        
        /**
         * send a value to one of the lisenenrs
         */
        send v = 
            (fn = synchronized mutex \(
                if empty? listeners then
                    \();
                else
                    if empty? curListeners then
                        curListeners := tail listeners;
                        head listeners;
                    else
                        r = head curListeners;
                        curListeners := tail curListeners;
                        r
                    fi
                fi);
            fn v),
            
        /**
         * send a value to all the listeners
         */
        publish v =
            fns = synchronized mutex \(listeners);
            for fns do fn: fn v done,
    });



/**
 * Group: container (CONTAINER)
 * Function to create a function with creates a verticle. Such a function
 * is the function expected by the YetiVerticleFactory which is used to run
 * yeti verticles.
 *
 * It is not necessary to use this function to create a yeti Verticle. You can
 * as well create your own function (() -> ~Verticle). Or your can straigth
 * implement your onw Verticle Subclass and run it like a normal Java Verticle.
 *
 * This function is just a helper function.
 *
 * Arguments:
 * startFunction - function which correspondents to the start method of 
 * Veritcle. The function is given a {vertx, container} struct. And the function
 * must retun a stop function, which is when clalled also given the 
 * a {vertx, container} struct
 *
 * Examples:
 * : module myverticle
 * :
 * : load yvertx;
 * :
 * : verticle do {vertx, container}:
 * :     //do all the start work
 * :     createHttpServerWithHandler .....;
 * :     
 * :     //return stop function
 * :     do:
 * :        ... do cleanup
 * :     done;
 * : done;
 *
 * However most of the time verxt and conatiner is not need, because
 * it can be gotten as properties of the vertx module and stop
 * is not needed as well
 * 
 * : module myverticle
 * :
 * : load yvertx;
 * :
 * : verticle do:
 * :     //do all the start work
 * :     createHttpServerWithHandler .....;
 * :     
 * :     //return stop function
 * :     \()
 * :     done;
 * : done;
 */
verticle runFn 
        is ({vertx is ~Vertx, container is ~Container} 
            -> ({vertx is ~Vertx, container is ~Container} -> 'a)) 
            -> ( () -> ~Verticle) =
   (import org.vertx.java.core:VoidResult;
   class IYetiVerticle extends Verticle 
        var stopFn = \(println "No stopfuntion assigned yet"),
        
        void start()
            stopFn := 
                runFn {vertx = this#getVertx(), 
                       container = this#getContainer()},
        void stop()
            stopFn {vertx = this#getVertx(), 
                    container = this#getContainer()},
    end;
    \(new IYetiVerticle() as ~Verticle));

/**
 * Group: container (CONTAINER)
 * 
 * Creates a new Verticle like the verticle function. However is
 * also given a started parameter, which is used to indicate that the verticle
 * is started. This is useful if the verticle deploys other modules and
 * should only be considered started when the started is indicated.
 *
 * Note that the verticle is not considered started as long as the started
 * funciton is not colled
 *
 * Examples:
 * : module myverticle
 * :
 * : load yvertx;
 * :
 * : verticle do {started}:
 * :     //do all the start work
 * :     createSomeThingWithCallback do:
 * :         //mark now as started
 * :         started ();
 * :     done;
 * :     
 * :     //return stop function
 * :     do:
 * :        ... do cleanup
 * :     done;
 * : done;
 *
 */
lateVerticle runFn 
        is ({vertx is ~Vertx, container is ~Container, started is () -> ()} 
            -> ({vertx is ~Vertx, container is ~Container} -> 'a)) 
            -> ( () -> ~Verticle) =
   (import org.vertx.java.core:VoidResult;
   class IYetiVerticle extends Verticle 
        var stopFn = \(println "No stopfuntion assigned yet"),
        
        void start(VoidResult res)
            stopFn := 
                runFn {vertx = this#getVertx(), 
                       container = this#getContainer(),
                       started () = _ = res#setResult()},
        void stop()
            stopFn {vertx = this#getVertx(), 
                    container = this#getContainer()},
    end;
    \(new IYetiVerticle() as ~Verticle));



/**
 * Group: container
 * Deploy a module programmatically
 *
 * Calls ~Container#deployModule
 *
 * Arguments:
 * moduleName - name of the module to deploy
 * config - JSON config to provide to the module (given as struct)
 * instances - number of instances to deploy
 * doneHandler - handler called when the module is succesful deployed
 */
deployModule name config instances handler = 
    (getContainer ())#deployModule(name is string, 
                                            toJson config, 
                                            instances is number, 
                                            toStringHandler handler);

/**
 * Group: container
 * Deploy a verticle progammatically
 *
 * Calls ~Container#deployVerticle
 *
 * Arguments:
 * verticleName - name of the verticle to deploy
 * config - JSON config to provide to the verticle (given as struct)
 * instances - number of instances
 * handler - called when succesful deploid. The handler is given the uniqueid
 */
deployVerticle name config instances handler= 
    (getContainer ())#deployVerticle(name is string, 
                                                toJson config, 
                                                instances is number, 
                                                toStringHandler handler);

/**
 * Group: container
 * Deploy a worker verticle progammatically
 *
 * Calls ~Container#deployWorkerVerticle
 *
 * Arguments:
 * verticleName - name of the verticle to deploy
 * config - JSON config to provide to the verticle (given as struct)
 * instances - number of instances
 * mulitThreaded - wheter multithreaded
 * handler - called when succesful deploid. The handler is given the uniqueid
 */
deployWorkerVerticle name config instances multiThreaded handler= 
    (getContainer ())#deployWorkerVerticle(name is string, 
                                                toJson config, 
                                                instances is number, 
                                                multiThreaded is boolean,
                                                toStringHandler handler);

/**
 * Group: container
 * The config given to this verticle
 *
 * Calls ~Container#getConfig()
 */
config () = fromJson ((getContainer ())#getConfig());


_enviroment () = 
   (ret = [:];
    forJavaMap ((getContainer ())#getEnv()) do key value: 
        ret[string key] := string value;
    done;
    ret);


/**
 * Group: container
 * undeploys the module with the given moduleId
 *
 * calls Container#undeployModule
 *
 * Arguments:
 * moduleId - the id of the module
 * hanlder - called when succesful undeployed
 */
undeployModule deploymentID handler =
    (getContainer ())#undeployModule(deploymentID, 
                                    toSimpleHandler handler);
/**
 * Group: container
 * undeploys a verticle
 *
 * calls Container#undeployVerticle
 *
 * Arguments:
 * verticleId - deploymentId of the verticle
 * handler - called when undeployment is complete
 */
undeployVerticle deploymentID handler =
    (getContainer ())#undeployVerticle(deploymentID, 
                                    toHandler handler);

class TimeOutException(long time) extends RuntimeException("Timedout \(time)")
     long getTime()
        time,
end;

/**
 * Group: async
 * Wraps an async callback function with timeout behauviour.
 *
 * If the callback is not invoke within the given timeoutMs than
 * an TimeOutException is passed in Excepition.
 *
 * Arguments:
 * timeoutMs - the timouout in Ms
 * callback - the callback function
 */
timeout timeMs asfn cb 
    is number -> asyncFunction<'a> -> asyncFunction<'a> = 
    (var handled = false;

    _ = setTimer (timeMs) do:
        if not handled then
            handled := true;
            cb (None ((new TimeOutException(timeMs)) as ~Exception));
        fi
    done;
    
    asfn do v:
        if not handled then
            handled := true;
            cb v
        fi
    done);

//http server things

/**
 * Group: httpServer (HTTP_SERVER)
 * sets the requestHandler on http server
 *
 * calls HttpServer#requestHandler
 *
 * Arguments:
 * server - the HttpServer
 * handlerFunction - function which gets the HttpServerRequests
 */
httpServerRequestHandler server handler =
   (server is ~HttpServer)#requestHandler(
        toHandler (handler . (unsafely_as ~HttpServerRequest)));
        
/**
 * Group: httpServer
 * create an HttpServer
 *
 * calls Vertx#createHttpServer;
 *
 */
createHttpServer () = 
    (getVertx())#createHttpServer();

/**
 * Group: httpServer
 * Creates an HttpServer and sets the given handler as requestHandler
 *
 * Same as
 * : server = createHttpServer ()
 * : httpServerRequestHandler handler
 * : server
 *
 * Arguments:
 * handler - the request handler set on the newly created http server
 */
createHttpServerWithHandler handler = 
    (getVertx())#createHttpServer()#requestHandler(
        toHandler (handler . (unsafely_as ~HttpServerRequest)));

/**
 * Group: httpServer
 * Closes the HttpServer
 *
 * Calls server#close(handler)
 *
 * Arguments:
 * server - the http server to close
 * doneHandler - called when server close is complete
 */
closeHttpServer server handler =
    (server is ~HttpServer)#close(toSimpleHandler handler);

/**
 * Group: httpServer
 * Creates a new RouteMatcher and wraps it with custom functions 
 * which do the same as the correspondending methods of RouteMatcher
 */
newRouteMatcher () =
   (import org.vertx.java.core.http:RouteMatcher;
   _rm = new RouteMatcher();
   toHa h = toHandler (h . (unsafely_as ~HttpServerRequest));
     
    {
        all route h = _ = _rm#all(route,toHa h), 
        allWithRegex route h = _ = _rm#allWithRegEx(route,toHa h), 
        connect route h = _ = _rm#connect(route,toHa h),
        connectWithRegEx route h = _ = _rm#connectWithRegEx(route,toHa h),
        delete route h = _ = _rm#delete(route,toHa h), 
        deleteWithRegEx route h = _ = _rm#deleteWithRegEx(route,toHa h), 
        get = do route h:  _ = _rm#get(route,toHa h) done,
        getWithRegEx route h = _ = _rm#getWithRegEx(route,toHa h), 
        head route h = _ = _rm#head(route,toHa h), 
        headWithRegEx route h = _ = _rm#headWithRegEx(route,toHa h), 
        options route h = _ = _rm#options(route,toHa h), 
        optionsWithRegEx route h = _ = _rm#optionsWithRegEx(route,toHa h), 
        patch route h = _ = _rm#patch(route,toHa h), 
        patchWithRegEx route h = _ = _rm#patchWithRegEx(route,toHa h), 
        post route h = _ = _rm#post(route,toHa h), 
        postWithRegEx route h = _ = _rm#postWithRegEx(route,toHa h), 
        put route h = _ = _rm#put(route,toHa h), 
        putWithRegEx route h = _ = _rm#putWithRegEx(route,toHa h), 
        trace route h = _ = _rm#trace(route,toHa h), 
        traceWithRegEx route h = _ = _rm#traceWithRegEx(route,toHa h), 
        noMatch h = _ = _rm#noMatch(toHa h),
        rm = _rm,
        handle req = _ = _rm#handle(req is ~HttpServerRequest),
        /**
         * create a server and set this routemachter as handler
         */
        createServer () = 
            (getVertx())#createHttpServer()#requestHandler(_rm),

        /**
         * add a route as string only the pattern is
         * "regex:"method:pattern
         * The constant string "regex:" is optional and marks that pattern is
         * a regex (otherwise it is a normal rout pattern)
         * The method is also optional and defines one of post, put, get etc.
         * The default method is all
         * Finally the pattern must be provided.
         *
         * Arguments:
         * route - a route pattern of the from ("regex:")?(method:)?pattern
         * see above description
         * handler - the handler for the argument
         */
        route fullpattern handler =
            ({regex,methodPattern} =
                if strStarts? fullpattern "regex:" then
                    {regex = true, 
                    methodPattern = strRight fullpattern 6}
                else
                    {regex = false,
                     methodPattern = fullpattern}
                fi;
            {method, pattern} =
                (cut = strIndexOf methodPattern ":" 0;
                if cut < 0 then
                    {method = "", pattern = methodPattern}
                else
                    {method = strUpper(strLeft methodPattern cut),
                    pattern = strRight methodPattern (cut + 1)}
                fi);
            h = toHa handler;
            if regex then
                case method of
                "ALL" : _rm#allWithRegEx(pattern,h);
                "CONNECT" : _rm#connectWithRegEx(pattern,h);
                "DELETE" : _rm#deleteWithRegEx(pattern,h);
                "GET" : _rm#getWithRegEx(pattern,h);
                "HEAD" : _rm#headWithRegEx(pattern,h);
                "OPTIONS": _rm#optionsWithRegEx(pattern,h);
                "PATCH" : _rm#patchWithRegEx(pattern,h);
                "POST" : _rm#postWithRegEx(pattern,h);
                "PUT" : _rm#putWithRegEx(pattern,h);
                "TRACE" : _rm#traceWithRegEx(pattern,h);
                _ : _rm#allWithRegEx(fullpattern, h);
                esac;
            else
                case method of
                "ALL" : _rm#all(pattern,h);
                "CONNECT" : _rm#connect(pattern,h);
                "DELETE" : _rm#delete(pattern,h);
                "GET" : _rm#get(pattern,h);
                "HEAD" : _rm#head(pattern,h);
                "OPTIONS": _rm#options(pattern,h);
                "PATCH" : _rm#patch(pattern,h);
                "POST" : _rm#post(pattern,h);
                "PUT" : _rm#put(pattern,h);
                "TRACE" : _rm#trace(pattern,h);
                _ : _rm#all(fullpattern, h);
                esac;

            fi)
    });        
        
/**
 * Group: httpServer
 * set the given headers as response headers on the requests response
 * 
 * Arguments:
 * serverRequest - the serverRequest object which holds the response
 * headers - hash headers
 */
putResponseHeaders request headers =
   ((request is ~HttpServerRequest)#response#headers()#putAll(
        (headers is hash<string,string>) as ~Map);
    ());

/**
 * Group: httpServer
 * set the given response trailers
 *
 * Arguments:
 * serverRequest - the serverReqeust object which holds the response
 * trailers - hash of trailers
 */
putResponseTrailers request trailers =
    ((request is ~HttpServerRequest)#response#trailers()#putAll(
        (trailers is hash<string,string>) as ~Map);
    ());

/**
 * Group: httpServer
 * the parameters of this request as hash
 *
 * Will always create a new hash for the parameters
 *
 * Arguments:
 * serverRequest - the request from which the parameters are taken
 */
params req =
   (ret = [:];
    forJavaMap (req is ~HttpServerRequest)#params() do key value:
        ret[string key] := if defined? value then string value else "" fi;
    done;
    ret);

/**
 * Group: httpServer
 * the headers of the HttpServerRequest
 *
 * Will always create a new hash for the headers
 *
 * Arguments:
 * serverReqeust - the request from which the headers are taken
 */
requestHeaders req =
    (ret = [:];
    forJavaMap (req is ~HttpServerRequest)#headers() do key value:
        ret[string key] := if defined? value then string value else "" fi;
    done;
    ret);

/**
 * Group: httpServer
 * sends the static file at the given path to the request
 *
 * Arguments
 * opts - WebRoot: the directory of the files to server (default is web);
 *        IndexPage: the file to serve for / (default is index)
 *        Gzip: wheter to search for zip files (deefault is false)
 * req - the HttpServerRequest
 * path - path of the file relative to webRoot
 */
serveStaticFileAtPath opts =
    (import java.io:File;
    import org.vertx.java.core.file.impl:PathAdjuster;
    var webRoot = "web";
    var gzipFiles = false;
    var indexPage = "index";
    for opts \case of
        WebRoot s : webRoot := s;
        Gzip b : gzipFiles := b;
        IndexPage s : indexPage := s;
    esac;

    webRootPrefix = webRoot ^ File#separator;
    indexPage = webRootPrefix ^ indexPage;
    
    do path req:
        headers = requestHeaders req;
        acceptEncodingGzip = if "accept-encoding" in headers then
                strIndexOf headers["accept-encoding"] "gzip" 0 > -1;
            else
                false
            fi;
        fileName = webRootPrefix ^ path;
        if path == "/" then
            req#response#sendFile(indexPage);
        elif strIndexOf path ".." 0 < 0 then
            if gzipFiles and acceptEncodingGzip then
                file = new File(PathAdjuster#adjust(
                        (getVertx()) unsafely_as ~VertxInternal,
                        fileName ^ ".gz"));
                if file#exists() then
                    req#response#putHeader("content-encoding", "gzip");
                    req#response#sendFile(fileName ^ ".gz");
                else
                    req#response#sendFile(fileName);
                fi
            else
                req#response#sendFile(fileName);
            fi
        else
            req#response#statusCode := 404;
            req#response#end();
        fi;
        ()
    done);

/**
 * Group: httpServer
 * Add a bodyHandler to HttpServerRequest
 *
 * Arguments:
 * httpStream - the HttpReadStreamBase
 * handler - the handler getting a buffer
 */
serverBodyHandler response handler =
   (response is ~HttpServerRequest)#bodyHandler(
        toBufferHandler handler);

/**
 * Group: httpServer
 * Takes a yebroute and creates a vertx HttpHandler.
 * used to Brigde between Vertx http and yeb.
 */
routeToHttpHandler opts yebroute =
    (import org.vertx.java.core.http:HttpServerRequest;
    //load yeb.mvc.mvc;
    fileHandler = serveStaticFileAtPath opts;
    do reqO:            
        serverBodyHandler reqO do buffer:
            
            req = {
                headers = requestHeaders reqO,
                uri = reqO#uri,
                path = reqO#path,
                method = reqO#method,
                params = 
                    ret = [:];
                    forHash (params reqO) do k v: ret[k]:=[v] done;
                    ret,
                body = buffer#getBytes(),
                resHeaders = [:],
            };
            try
                (yebroute) req 
                    \case of
                    None ex:
                        reqO#response#statusCode := 404;
                        _ = reqO#response#end();
                        throw (ex is ~Exception);
                    Some res: 
                        if res.statusCode == -1 //continueStatusCode 
                            then
                            reqO#response#statusCode := 404;
                            _ = reqO#response#end();
                        elif res.statusCode == -2 then
                            path = res.headers["file"];
                            fileHandler path reqO;
                        else
                            reqO#response#statusCode := res.statusCode;
                            putResponseHeaders reqO res.headers;
                            if not res.body == new byte[0]//noneBody then
                                then
                                buffer = new Buffer(res.body is ~byte[]);
                                reqO#response#putHeader("Content-Length", 
                                        string buffer#length());
                                reqO#response#write(buffer);
                            fi;
                            _ = reqO#response#end();
                        fi;
                    esac;
            catch Exception ex:
                reqO#response#statusCode := 404;
                _ = reqO#response#end();
                throw (ex is ~Exception);
            yrt;
        done
    done);

/**
 * Group: httpServer
 *
 * Creates an  yebHandler which fans out to many vertx workers yebHandlers.
 * Takes a factory function which produdes routes and returns an
 * async function from which one yebroute can be gotten. This route will
 * fan out its request to the route produced by the factory function
 */
createRequestWorkers numberOfWorkers yebHandlerFactoryFn = 
    (load yeb.async;

    fibre = newFibre();

    [1 .. numberOfWorkers]
    |>map' \(newWorker 
        \(route = yebHandlerFactoryFn ();
        _ = fibre.register do {req,res}: route req res done;
        ))
    |>parallel 
    |>bind \(return do req res:
        fibre.send {req, res};
    done));

/**
 * Group: httpServer
 *
 * Creates a VertxHttpHandler which bridges to a number of worker
 * yebHandlers
 */
createYebHttpServer timeOutMs httpOpts numberOfWorkers yebHandlerFactoryFn =
    (load yeb.async;

    createRequestWorkers numberOfWorkers yebHandlerFactoryFn
        |> bind (return . routeToHttpHandler httpOpts)
        |> await timeOutMs
        |> createHttpServerWithHandler);
//http client things


/**
 * Group: httpClient (HTTP_CLIENT)
 * creates an http client for the given host:port
 *
 * Arguments:
 * hostPort - a string giving host:port (see hostAndPort function)
 */
createHttpClient hostPort = 
   ({port,host} = hostAndPort hostPort; 
    (getVertx())#createHttpClient()#setPort(port)#setHost(host));

/**
 * Group: httpClient
 * put the given headers on the client request
 *
 * Arguments:
 * request - the request to put the headers on
 * headers - a hash of headers where each is put on the client
 */
putRequestHeaders request headers =
   ((request is ~HttpClientRequest)#headers()#putAll(
        (headers is hash<string,string>) as ~Map);
    request);

/**
 * Group: httpClient
 * get the headers from the HttpClientResponse
 *
 * Arguments:
 * clientResponse - the http response
 */
responseHeaders resp =
    (ret = [:];
    forJavaMap (resp is ~HttpClientResponse)#headers() do k v:
        ret[string k] := if defined? v then string v else "" fi;
    done;
    ret);

/**
 * Group: httpClient
 * get the trailers from the HttpClientResponse as hash
 *
 * Arguments:
 * clientResponse - the http response
 */
responseTrailers resp =
    (ret = [:];
    forJavaMap (resp is ~HttpClientResponse)#trailers() do k v:
        ret[string k] := if defined? v then string v else "" fi;
    done;
    ret);

/**
 * Group: httpClient
 * create an http request for the given client
 *
 * Calls - depending on the muri - one of the HttpClient request mehtod (get, put,
 * post, delete etc)
 *
 * Arguments:
 * client - the httpclient
 * muri - the uri with the method as a Tag (Post, Get, Delete etc)
 * options - options to set headers, send content and work on the request 
 * handler - the reqeusthandler
 *
 */
httpRequest client muri opts handler =  
    (h = toHandler  (handler . (unsafely_as ~HttpClientResponse));
    req = case muri of
    Connect uri: 
        (client is ~HttpClient)#connect(uri is string, h);
    Delete uri:    
        client#delete(uri is string, h);
    Get uri: 
        client#get(uri is string, h);
    Head uri:
        client#head(uri is string, h);
    Options uri:
        client#options(uri is string, h);
    Patch uri:
        client#patch(uri is string, h);
    Put uri:
        client#put(uri is string, h);
    Post uri:
        client#post(uri is string, h);
    Trace uri:
        client#trace(uri is string, h);
    Request {method, uri}:
        client#request(method is string, uri is string, h); 
    esac;

    for opts \case of
    Headers ha : _ = putRequestHeaders req ha;
    WithRequest fn : fn req;
    JsonContent str : 
        bu = new Buffer(str is string);
        _ = putRequestHeaders req 
            ["Content-Type":"application/json; charset=utf-8",
            "Content-Length": string bu#length()];
        _ = req#write(bu);
    FormEncoded ha :
        import java.net.URLEncoder;
        bu = new Buffer();
        var first = true;
        forHash ha do pname values:
            name = URLEncoder#encode(pname, "UTF-8"); 
            for values do pvalue:
                value = URLEncoder#encode(pvalue, "UTF-8");
                if first then
                    first := false;
                else
                    _ = bu#appendString("&");
                fi;
                _ = bu#appendString(name)
                    #appendString("=")
                    #appendString(value);
            done;
        done;
        _ = putRequestHeaders req
            ["Content-Type":"application/x-www-form-url; charset=utf-8",
            "Content-Length": string bu#length()];
        _ = req#write(bu);
    
    TextContent str:
        bu = new Buffer(str is string);
        _ = putRequestHeaders req 
            ["Content-Type":"text/plain; charset=utf-8",
            "Content-Length": string bu#length()];
        _ = req#write(bu);

    BufferContent {type, buffer}:
        headers = ["content-Length": string (buffer is ~Buffer)#length()];
        if defined? (type is string) then
            headers["Content-Type"] := type;
        fi;
        _ = putRequestHeaders req headers; 
        _ = req#write(buffer);
    
    Timeout ms:
        _ = req#setTimeout(ms is number);
    esac;
    req);

/**
 * Group: httpClient
 * Add a bodyHandler to HttpClientResponse
 *
 * Arguments:
 * httpStream - the HttpReadStreamBase
 * handler - the handler getting a buffer
 */
clientBodyHandler response handler =
   (response is ~HttpClientResponse)#bodyHandler(
        toBufferHandler handler);

/**
 * Group: httpClient
 * create and execute an http request for the given client
 *
 * Calls - depending on the muri - one of the HttpClient request mehtod (get, 
 * put, post, delete etc)
 *
 * Arguments:
 * client - the httpclient
 * muri - the uri with the method as a Tag (Post, Get, Delete etc)
 * options - options to set headers, send content and work on the request 
 * handler - the reqeusthandler
 *
 */
httpRequestNow client murl opts handler =  
    (var handled = false;
    req = httpRequest client murl opts do response:
        exceptionHandler response do ex:
            if not handled then
                handled := true;
                handler (None ex)
            fi
        done;
        clientBodyHandler response do body:
            if not handled then
                handled := true;
                handler (Some {body, response});
            fi;
        done
    done;

    wsExceptionHandler req do ex:
        if not handled then
            handled := true;
            handler (None ex);
        fi
    done;

    req#end());

//websocket functions

/**
 * Group: websocket (WEBSOCKET)
 * sets the handler as websocketHandler on the given http server
 *
 * calls HttpServer#websocketHandler
 *
 * Arguments:
 * server - HttpServer
 * websocketHanlder - handler for handling the ServerWebSocket
 */
connectWebSocketServer server fn =
    ((server is ~HttpServer)#websocketHandler(
            toHandler (fn . (unsafely_as ~ServerWebSocket)));
    ());

/**
 * Group: websocket 
 * connects the websocket handler to the HttpClient.
 *
 * calls HttpClient#connectWebSocket
 *
 * Arguments:
 * client - HttpClient
 * uri - the uri for the websocket
 * handler - the function which gets the WebSocket
 */
connectWebSocketClient client uri handler =
    (client is ~HttpClient)
        #connectWebsocket(uri is string,
                          toHandler (handler .(unsafely_as ~WebSocket)));

/**
 * Group: websocket
 * adds a closedHandler on the Websocket
 * 
 * calls WebSocket#closedHandler
 *
 * Arguments:
 * socket - the WebSocket
 * handler - the closedHandler
 */
closedWebSocket socket handler =
   (socket is ~WebSocket)#closedHandler(toSimpleHandler handler);


//sockjs functions

/**
 * Group: sockjs (SOCKJS)
 * creates a sockjs server
 *
 * calls Vertx#createSockJSServer
 *
 * Arguments:
 * server - httpServer
 */
createSockJSServer server =
    (getVertx())#createSockJSServer(server);

/**
 * Group: sockjs
 * install SockJSApp
 *
 * calls SockJSServer#installApp
 *
 * Arguments:
 * server - SockJSServer
 * config - sockjs application configuration
 * sockHandler - handler that will be called when new SockJS sockets are 
 * created;
 */
installSockJSApp server config handler =
    (server is ~SockJSServer)#installApp(toJson config, 
                 toHandler (handler . (unsafely_as ~SockJSSocket)));  

/**
 * Group: sockjs
 * Intall an app wich bridges the SockJS server to the event bus
 *
 * calls SockJSServer#bridge
 *
 * Arguments:
 * server - SockJSServer
 * opts - list of auth options
 *        AuthTimeout authentication time ms default is 5 minutes
 *        AuthAddress authentication addres default is 
 *        vertx.basicauthmanager.athorise
 * sjsConfig - the config for the app
 * inboundPermitted - list of structs which is transformed to json and
 *                    have to mathc the inbound permitted message
 * outboundPermitted - like inboundPermitted for traffic out
 */
bridgeSockJS server opts sjsConfig inboundPermitted outboundPermitted =
   (var authTimeout = 5 * 60 * 1000;
    var authAddress = "vertx.basicauthmanager.athorise";
    for opts do opt:
        case opt of
        AuthTimeout n : authTimeout := n;
        AuthAddress a : authAddress := a;
        esac
    done;
    (server is ~SockJSServer)#bridge(toJson sjsConfig, 
             toJsonArray (inboundPermitted is list<jsonStruct<'e>>), 
             toJsonArray (outboundPermitted is list<jsonStruct<'f>>),
             authTimeout,
             authAddress));


//net functions

/**
 * Group: net (NET)
 * add closedHanlder on a netsocket
 *
 * calls NetSocket#closed
 *
 * Arguments:
 * socket - NetSocket
 * hanlder - closedHanlder
 */
netsocketClosed socket handler =
    (socket is ~NetSocket)#closedHandler(toSimpleHandler handler);

/**
 * Group: net
 * create a net client
 *
 * calls Vertx#createNetClient
 */
createNetClient () = 
    (getVertx())#createNetClient();

/**
 * Group: net
 * connects the given handler to the given client at the port
 *
 * calls NetClient#exceptionHandler and NetClient#connect
 *
 * Arguments:
 * netClient - the NetClient
 * hostPort - string of form "host:port" see functin hostAndPort
 * exceptionHandler - the exceptionHandler registeres with #exceptionHandler
 * netClientHandler - the clientHandler
 */
connectNetClient client hostPort exceptionHandler handler =
    ({host,port} = hostAndPort hostPort;
     (client is ~NetClient)#exceptionHandler(
            toExceptionHandler exceptionHandler);
     _ = client#connect(port is number, host is string,
                toHandler (handler . (unsafely_as ~NetSocket)));
     ());

/**
 * Group: net
 * creats and connects the net client
 * same as createNetClient and connectNetClient in one operation
 * 
 * Arguments:
 * hostPort - string of form "host:port" see functin hostAndPort
 * exceptionHandler - the exceptionHandler registeres with #exceptionHandler
 * netClientHandler - the clientHandler
 */
createAndConnectNetClient hostPort settings exceptionHandler handler=
    (client = createNetClient ();
    _ = settings client;
    connectNetClient client hostPort exceptionHandler handler;
    client);

/**
 * Group: net
 * creates a net server
 *
 * calls Vertx#createNetServer;
 */
createNetServer () =
    (getVertx())#createNetServer();

/**
 * Group: net
 * connects the handler to the NetServer
 *
 * calls NetServer#connectHandler;
 *
 * Arguments:
 * server - the NetServer
 * hanlder - the NetSocketHandler
 */
connectNetServer server handler =
    (server is ~NetServer)#connectHandler(
        toHandler (handler . (unsafely_as ~NetSocket)));

/**
 * Group: net
 * creates a NetServer and connects the handler
 *
 * Same as createNetServer and connectNetServer in one operation
 *
 * Arguments:
 * handler - the NetSocket hanlder
 */
createAndConnectNetServer handler =
    connectNetServer(createNetServer ()) handler;

/**
 * Group: net
 * closes the NetServer
 *
 * calls NetServer#close
 *
 * Arguments:
 * server - the NetServer
 * doneHandler - handler called when close is complete
 */
closeNetServer server handler =
    (server is ~NetServer)#close(toSimpleHandler handler);

/**
 * Group: net
 * closes the NetClient
 *
 * calls NetClient#close
 *
 * Arguments:
 * netClinet - the NetClient
 */
closeNetClient client =
    (client is ~NetClient)#close();


//bus things

_toMessageJS v =
    case v of
    None ex: 
        toJson {status = "error", 
              message = string (ex is ~Exception)#getMessage(),
              exception = string ex,
              for_json = E()};
    Some va: toJson va;
    esac;


toRequestMessageHandler fn =
    (class YvertxRequestMessageHandler extends Handler
        void handle(Object ob)
            msg = ob unsafely_as ~Message;
            {jsonStruct = body} = fromJson (msg#body unsafely_as ~JsonObject);
            if defined? body.status and body.status == "error" then
                emg = if defined? body.message then
                          string body.message
                      else 
                          "error but no message" 
                      fi;
                fn (failNone emg);
            else
                fn (Some body)
            fi,

    end;
    new YvertxRequestMessageHandler() as ~Handler);

toEitherJsonMessageHandler address fn =
    (class YvertxEitherMessageHandler extends Handler
        void handle(Object ob)
            msg = ob unsafely_as ~Message;
            {jsonStruct = body} = fromJson (msg#body unsafely_as ~JsonObject);
            try
            if defined? body.status and body.status == "error" then
                emg = if defined? body.message then
                          string body.message
                      else 
                          "error but no message" 
                      fi;
                fn (failNone emg);
            else
                fn (Some  
                    {message = msg is ~Message,
                    handlerId =  
                        {object = this as ~Handler,
                        address is string},
                    body,
                    get replyAddress () = string msg#replyAddress,
                    reply v = 
                        msg#reply(_toMessageJS (Some v)),
                    replyEither v = 
                        msg#reply(_toMessageJS v),
                    request v handler = 
                        msg#reply(_toMessageJS (Some v), 
                            toEitherJsonMessageHandler address handler),
                    requestEither v handler = 
                        msg#reply(_toMessageJS v, 
                            toEitherJsonMessageHandler address handler)
                   });
            fi
            catch Exception ex:
                msg#reply(_toMessageJS (None ex));
            yrt,

    end;
    new YvertxEitherMessageHandler() as ~Handler);

toJsonMessageHandler address fn =
    (class YvertxMessageHandler extends Handler
        void handle(Object ob)
            msg = ob unsafely_as ~Message;
            try
            fn {message = msg is ~Message,
                handlerId =  
                    {object = this as ~Handler,
                    address is string},
                get body () = 
                    fromJson (msg#body unsafely_as ~JsonObject),
                get replyAddress () = string msg#replyAddress,
                reply v = 
                    msg#reply(_toMessageJS (Some v)),
                replyEither v = 
                    msg#reply(_toMessageJS v),
                request v handler = 
                    msg#reply(_toMessageJS (Some v), 
                        toEitherJsonMessageHandler address handler),
                requestEither v handler = 
                    msg#reply(_toMessageJS v, 
                        toEitherJsonMessageHandler address handler)
               };
            catch Exception ex:
                msg#reply(_toMessageJS (None ex));
            yrt,
    end;
    new YvertxMessageHandler() as ~Handler);

/**
 * Group: eventbus (EVENTBUS)
 * publish a JSON message on the eventbus
 *
 * Note only structs can be published here
 *
 * calls EventBus#publish
 *
 * Arguments:
 * address - the address to publish to
 * structMessage - the struct which will be posted as Json
 */
publishToBus address msg = 
    (getVertx ())#eventBus()#publish(address is string, toJson msg);

/**
 * Group: eventbus
 * send a JsON message on the eventbus
 *
 * Note only struct can be send as message here
 *
 * calls EventBus#send
 *
 * Arguments:
 * address - the address to send to
 * structMessage - the struct which will be send as JSON
 */
sendToBus address msg =
    (getVertx ())#eventBus()#send(address is string, toJson msg);

/**
 * Group: eventbus
 * send a Json message on the eventbus with a normal handler
 *
 * Note only struct can be send/received 
 *
 * calls Eventbus#send
 *
 * Arguments:
 * address - the address to send to
 * structMessage - struct iwht will be sind
 * handler - the callback function receiving the response
 */
sendToBusWithHandler address msg handler =
    (getVertx ())#eventBus()#send(address is string, toJson msg, 
            toJsonMessageHandler address handler);


/**
 * Group: eventbus
 * send a Json message on the eventbus and receive either
 * Some jsonResponse or None exception. 
 *
 * If the response has the field status with error (like busmods do)
 * a None is given as value to the callback, Otherwise a Some with the
 * the json value.
 *
 * Note only struct can be sent as message here.
 *
 * Arguments:
 *
 * address - the address to send to
 * structMessage - the struct which will be sind as JSON
 * responseHandler - the handler which gets the response struct
 *
 * example:
 * : requestFromBus "fooAdress" {msg="some", for_json=E()} \case of:
 * :    None ex: //hanlde failure
 * :    Some val: //handle json value
 * : esac;
 *
 */
requestFromBus address msg handler =
    (getVertx ())#eventBus()#send(address is string, toJson msg, 
            toRequestMessageHandler handler);

/**
 * Group: eventbus
 * register a JSON message handler on the eventbus
 *
 * Note only JsonMessages can be handled this way
 *
 * calls EventBus#registerHandler
 *
 * Arguments:
 * address - the bus address to register to
 * readyHandler - is informed when the message handler is registered in
 * the whole cluster
 * messageHandler - the handler which receives the messages
 */
registerBusHandler address resultHandler handler =
    (ha = toJsonMessageHandler address handler;
    ret = {object = ha, address};
    (getVertx ())#eventBus()#registerHandler(address is string,
                            ha,
                            toAsyncResultHandler \(resultHandler ret));
    ret);

/**
 * Group: eventbus
 * registers a local handler on the eventubs
 *
 * Note only JsonMessage can be handled this way
 *
 * calls EventBus#registerLocalHandler
 *
 * Arguments:
 * address - the address to regsiter to
 * handler - the message handeler
 */
registerLocalBusHandler address handler =
    (ha = toJsonMessageHandler address handler;
    (getVertx ())#eventBus()#registerLocalHandler(address is string,
                   ha);
    {object = ha, address});
        
/**
 * Group: eventbus
 * deregisters the given handler
 *
 * calls EventBus#unregisterHandler
 *
 * Arguments:
 * id - the handler id
 * handler - the hanlder to deregister 
 *      (it is given to the handler on each call)
 */
unregisterBusHandler {address,object} resultHandler =
    (getVertx ())#eventBus()#unregisterHandler(address is string, object, 
                          toAsyncResultHandler resultHandler);


//filesystem
fsHelper = {
    closeAFile file handler =
        (file is ~AsyncFile)#close(toAsyncResultHandler handler),

    flushAFile file handler =
        (file is ~AsyncFile)#flush(toAsyncResultHandler handler),

    readAFile file buffer offset position length handler =
        (file is ~AsyncFile)#read(buffer is ~Buffer, offset is number,
                                  position is number,
                                  length is number,
                                  toTypedAsyncResultHandler 
                                    (unsafely_as ~Buffer) handler),

    writeAFile file buffer position handler =
        (file is ~AsyncFile)#write(buffer is ~Buffer, position is number,
                                   toAsyncResultHandler handler),
};

/**
 * Group: file (FILE)
 * Wrapper around all the async method of FileSystem. The functionality
 * and arguments are the same as there
 */
fileSystem = ({
    get fs () = ((getVertx ())#fileSystem()),
    chmod path perms handler =
        ((getVertx())#fileSystem())#chmod(path is string, perms is string, 
                    toAsyncResultHandler handler),

    chmodDir path perms dirPerms handler =
        ((getVertx ())#fileSystem())#chmod(path is string, 
                         perms is string, dirPerms is string,
                         toAsyncResultHandler handler),

    copy from to recursive handler =
        ((getVertx ())#fileSystem())#copy(from is string, to is string, 
                         recursive is boolean, toAsyncResultHandler handler),

    createFile path perms handler =
        case perms of
        None _ :
            ((getVertx ())#fileSystem())#createFile(path is string, 
                                            toAsyncResultHandler handler);
        Some perm:
            ((getVertx ())#fileSystem())#createFile(path, perm is string, 
                        toAsyncResultHandler handler);
        esac,

    delete path recursive handler =
        ((getVertx ())#fileSystem())#delete(path is string, 
                    recursive is boolean, 
                    toAsyncResultHandler handler),

    exists path handler =
        ((getVertx ())#fileSystem())#exists(path is string, 
                toTypedAsyncResultHandler (unsafely_as boolean) handler),
        
    fsProps path handler =
        ((getVertx ())#fileSystem())#fsProps(path is string, 
                     toTypedAsyncResultHandler 
                        (unsafely_as ~FileSystemProps) handler),

    link link existing handler =
        ((getVertx ())#fileSystem())#link(link is string, existing is string, 
                    toAsyncResultHandler handler),
     
    lprops path handler =
        ((getVertx ())#fileSystem())#lprops(path is string, 
                    toTypedAsyncResultHandler 
                        (unsafely_as ~FileProps) handler),

    mkdir path perms createParents handler =
        case perms of
        None () : 
            ((getVertx ())#fileSystem())#mkdir(path is string, 
                       createParents is boolean, toAsyncResultHandler handler);
        Some perm:
            ((getVertx ())#fileSystem())#mkdir(path is string, perm is string, 
                       createParents is boolean, toAsyncResultHandler handler);
        esac,

    move from to handler =
        ((getVertx ())#fileSystem())#move(from is string, to is string, 
                                          toAsyncResultHandler handler),

    props path handler =
        ((getVertx ())#fileSystem())#props(path is string, 
                   toTypedAsyncResultHandler (unsafely_as ~FileProps) handler),
        
    readDir path filter handler =
       (mfn obj = ((obj is ~Object) unsafely_as ~String[]) as list<string>;
        case filter of
        None ():
            ((getVertx ())#fileSystem())#readDir(path is string, 
                         toTypedAsyncResultHandler mfn handler);
        Some fil:
            ((getVertx ())#fileSystem())#readDir(path is string, 
                         fil is string, toTypedAsyncResultHandler mfn handler);
        esac),

    readFile path handler =
        ((getVertx ())#fileSystem())#readFile(path is string, 
                      toTypedAsyncResultHandler (unsafely_as ~Buffer) handler),

    readSymlink path handler =
        ((getVertx ())#fileSystem())#readSymlink(path is string, 
                         toTypedAsyncResultHandler 
                            (unsafely_as string) handler),
        
    symlink link existing handler =
        ((getVertx ())#fileSystem())#symlink(link is string, 
                     existing is string, 
                     toAsyncResultHandler handler),

    truncate path len handler =
        ((getVertx ())#fileSystem())#truncate(path is string, 
                      len is number, toAsyncResultHandler handler),

    unlink link handler =
        ((getVertx ())#fileSystem())#unlink(link is string, 
                                            toAsyncResultHandler handler),

    writeFile path data handler =
        ((getVertx ())#fileSystem())#writeFile(path is string, 
                       data is ~Buffer, 
                       toAsyncResultHandler handler),

    open opts path handler =
       (var createNew = true;
        var flush = false;
        var read = true;
        var write = true;
        var perms = () as ~String;
        for opts do opt:
            case opt of
            CreateNew b : createNew := b;
            Read b: read := b;
            Write b: write := b;
            Flush b: flush := b;
            Perms s: perms := s;
            esac
        done;
        
        ((getVertx ())#fileSystem())#open(path is string, perms, read, 
                  write, createNew, flush, 
                  toTypedAsyncResultHandler 
                        (unsafely_as ~AsyncFile) handler)),

    } with fsHelper);


 
{
    await,
    /**
     * Group: vertx
     * context property calls gets the context from VertxInternal
     * This is no public vertx api.
     */
    get context () =  _currentContext (),
    
    /**
     * Group: vertx
     * adds a close hook on context
     *
     * calls Context#putCloseHook
     *
     * Arguments:
     * key - the hook key
     * fn - the hook function
     */
    addCloseHook key fn = 
        (_currentContext())#putCloseHook(key is string, runnable fn),
    
    

    toHandler, 
    toSimpleHandler,
    toAsyncResultHandler, 
    toExceptionHandler,
    toBufferHandler,
    
    dataHandler,
    endHandler,
    exceptionHandler,
    drainHandler,
    wsExceptionHandler,
    
    verticle,
    lateVerticle,

    /**
     * Group: buffer (BUFFER)
     * creates an empty new Buffer of the given initial length
     *
     * Arguments:
     * length - the initial length of the buffer
     */
    newBuffer size = new Buffer(size is number),
    
    /**
     * Group: buffer
     * creates a new Buffer from the given string.
     * The string is encoded in UTF-8
     */
    newStringBuffer str = new Buffer(str is string),
    
    /**
     * Group: buffer
     * create a new Buffer from the given string with the given encoding
     *
     * Arguments:
     * encoding - the encoding to use ie "UTF-16"
     * str - the content of the buffer
     */
    newEncodedBuffer encoding str = 
        new Buffer(str is string, encoding is string),
    
    /**
     * Group: buffer
     * creates a new Buffer from the given byte-array
     *
     * Arguments:
     * bytes - the byte array contained in the new buffer
     */
    newByteBuffer bytes =
        new Buffer(bytes is ~byte[]),
   
    /**
     * Group: buffer
     * creates a new random Byte Buffer with the given length
     */
    newRandomBuffer len =
        new Buffer(YebUtils#generateRandomByteArray(len is number)),

    /**
     * Group: pump (PUMP)
     * creates a pump between a read and a write stream
     *
     * calls Pump#create
     *
     * Arguments:
     * readStream - the stream to read from
     * writeStream - the stream to write to
     */
    createPump readStream writeStream = 
        Pump#createPump(readStream, writeStream), 

    runOnLoop, 
    setPeriodic, 
    setTimer, 

    /**
     * Group: container
     * property for the logger from the container
     *
     * calls Container#getLogger()
     */
    get logger () = (getContainer ())#getLogger(),
    
    /**
     * Group: vertx
     * property of shardData
     *
     * calls Vertx#sharedData()
     */
    get sharedData ()= 
        (getVertx ())#sharedData(),
    
    

    deployModule, 
    deployVerticle, 
    deployWorkerVerticle,
    config, 

    /**
     * Group: container
     * property of the containers enviroment as hash<string,string>
     * 
     * calls Container#getEnviroment
     */
    get enviroment () = _enviroment (),
    undeployModule, 
    undeployVerticle,

    hostAndPort,
    toTypedAsyncResultHandler,
    
    //http server functions
    serverBodyHandler,
    httpServerRequestHandler,
    createHttpServer,
    createHttpServerWithHandler,
    closeHttpServer,
    newRouteMatcher,
    putResponseHeaders,
    putResponseTrailers,
    params,
    requestHeaders,
    serveStaticFileAtPath,

    routeToHttpHandler, 
    createRequestWorkers,
    createYebHttpServer,

    //http client functions
    clientBodyHandler,
    createHttpClient,
    putRequestHeaders,
    responseHeaders,
    responseTrailers,
    httpRequest,
    httpRequestNow,
    //websocket
    connectWebSocketServer,
    connectWebSocketClient,
    closedWebSocket,

    //sockjs
    installSockJSApp,
    bridgeSockJS,
    createSockJSServer,

    //net functions
    netsocketClosed,
    createNetClient,
    connectNetClient,
    createAndConnectNetClient,
    connectNetServer,
    createNetServer,
    createAndConnectNetServer,
    closeNetServer,
    closeNetClient,

    //bus functions
    publishToBus,
    sendToBus,
    sendToBusWithHandler,
    requestFromBus,
    registerBusHandler,
    registerLocalBusHandler,
    unregisterBusHandler,

    /**
     * Group: eventbus
     * property for the eventbus object from vertx
     *
     * primarly used to send other values than json objects
     */
    get eventBus () =
        (getVertx ())#eventBus(),

    //filesystem
    fileSystem,


    timeout,
    cancelTimer,

    getContainer,
    getVertx,
    /**
     * Group: container
     * property for the current container 
     * 
     * calls function getContainer () see there for better description
     */
    get container () = getContainer(),
    
    /**
     * Group: vertx
     * property for the current vertx
     *
     * calls function getVertx () see there for better description
     */
    get vertx () = getVertx(),
    
    //recordparser

    /**
     * Group: recordparser (RECORDPARSER)
     * creates a fixed RecordParser
     *
     * calls RecordParser#newFixed
     *
     * Arguments:
     * size - record length
     * handler - bufferHandler which gets each record
     */
    fixedRecordParser size handler = 
       (parser = RecordParser#newFixed(size is number, 
                                       toBufferHandler handler);
        do buffer: parser#handle(buffer is ~Buffer) done),
    
    /**
     * Group: recordparser
     * creates a delimited RecordParser
     *
     * calls RecordParser#newDelimited
     *
     * Arguments:
     * delimiter - the delimieter
     * hanlder - the bufferhander
     */
    delimitedRecordParser delimiter handler = 
       (parser = RecordParser#newDelimited(delimiter is string, 
                                       toBufferHandler handler);
        do buffer: parser#handle(buffer is ~Buffer) done),    
    
    emptyJS,
    toJson,
    toJsonArray,
    fromJson,
    fromJsonArray,
    blend,
    newFibre,
    newWorker,
}
