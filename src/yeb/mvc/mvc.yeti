/*
 * Copyright 2011 Christian Essl
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 */

module yeb.mvc.mvc;

import java.lang:Character,
                 Long;
import java.util:Locale;
import java.util.regex:Pattern;
import java.net:URLEncoder, 
            URLDecoder;

import yeb.ValidationException;

    

load yeb.std;
load yeb.async;
load yeb.validation;
util = load yeb.mvc.impl.util;

typedef cookie = {
    name is string,
    comment is string,
    commentUrl is string,
    domain is string,
    maxage is number,
    path is string,
    secure is boolean,
    value is string,
};

typedef response = {
    var statusCode is number,
    headers is hash<string,array<string>>,
    var body is ~byte[],
};


typedef request = {
    method is string,
    url is string,
    headers is hash<string, string>,
    body is ~byte[],
    mountPath is string,
    path is string,
    params is hash<string,list<string>>,
    queryParams is hash<string,list<string>>,
    bodyParams is hash<string, list<string>>,
    allParams is hash<string,list<string>>,
    cookies is hash<string,cookie>
};


typedef route = request -> asyncFunction<response>;

escape = util.escape;

/**
 * Group: send (SEND)
 *
 * This function should be used to create the response struct
 * Creates a new response structure which can be sent to the response
 * handler.
 *
 * The headers hash of the response has a default set to an empty
 * array which is also added to the hash itself.
 */
response statusCode headers body = 
    ({var statusCode = statusCode, 
     headers = 
        ha = [:] is hash<string,array<string>>;
        forHash headers do k v:
            ha[k] := array [v]
        done;
        setHashDefault ha do k:
            ar = array [];
            ha[k] := ar is array<string>;
            ar
        done;
        ha,
     var body = body} is response);

/**
 * Group: send
 *
 * Internal response object used to signal that the route-searching should
 * continue
 */
continue is response = 
    response (-1) [:] util.noneBody;

_sContinue = Some continue;    

/**
 * Group: request (REQUEST)
 *
 * Creates a new request. This function should be used to create a request.
 * The params, queryParams, bodyParams fields have a hash which defaults
 * to an empty list. 
 *
 * Arguments:
 * - method: the http method in upper case
 * - url: the url of the request (whtihout domain and scheme)
 * - path: the path part of the url without query
 * - headers: a map of headers 
 */
request {method,url,path,headers} =
    (
    params = listHash(); 
    queryParams = listHash(); 
    bodyParams = listHash(); 
    allParams = 
        (ha = [:];
        setHashDefault ha do k:
            if k in params then
                params[k];
            elif k in queryParams then
                queryParams[k];
            elif k in bodyParams then
                bodyParams[k]
            else
                []
            fi;
        done;
        ha);
                
    {
    method = strUpper method,
    url,
    headers,
    body = util.noneBody,
    mountPath = path,
    path,
    params,
    queryParams,
    bodyParams,
    allParams,
    cookies = [:]
    } is request);





    

/*
oldFlashKey = "org.yeb.session.oldflash";
flashKey = "org.yeb.session.flash";

getFlash name req =
    (if oldFlashKey in (req is request).res.session then
        s = req.res.session[flashKey] unsafely_as hash<string,~Object>;
        if name in s then
            Some s[name];
        else
            none
        fi
    elif flashKey in req.res.session then
        s = req.res.session[flashKey] unsafely_as hash<string, ~Object>;
        if name in s then
            Some s[name];
        else
            none
        fi
    else
        none;
    fi);

setFlash name value req =
    (m = if flashKey in (req is request).res.session then
        (req.res.session[flashKey]) unsafely_as hash<string, ~Object>
    else
        r = [:];
        req.res.session[flashKey] := (r as ~Object);
        r
    fi;
    m[name] := value as ~Object);
*/


///////////////////////////////////////////////
//route things
_patternMatchAll = 
        matchAll '(/?\.?):([A-Za-z0-9]+)(\$([^\$]+)\$)?(\?)?' (Token . tail) Text;

/**
 * Transform an url pattern to a regex. Patterns are used in routers to 
 * specify path pattern which should be handled.
 *
 * ie for the pattern:
 * :/entry/:id/:date
 * becomes the regex
 * :/entry/([^/]+)/([^/]+)/(.*)
 * and the matched parts are exposed as request-parameters
 *
 * to specify a custom regex put it between $ $ after the name of the part.
 * ie to specify that id should only contain digits:
 * :/entry/:id$d+$
 */
patternToRegex pat = 
   (//:a-z is name
    //:a-z? is optional
    //* at end means rest
    //$marks start regex $ marks end regex
    
    import java.util.regex.Pattern;
    
    paS = if strEnds? pat "/*" then 
                    strLeft pat (strLength pat - 2)
               else
                    pat;
               fi;
               
    tokens = _patternMatchAll paS;
    
    
    reg = tokens
    |> map do x:
        case x of
        Token [leading, name, _, regex, mark]:
           (reg = if defined? regex and (strLength regex > 0) then 
                    regex;
                  else
                    '[^/\.]+'
                  fi;
            reg = "(?<\(name)>\(reg))";
            
            if defined? mark then
                if defined? leading then
                    "(?:\(Pattern#quote(leading))" ^ reg ^ ")?" ;
                else
                    reg ^ "?";
                fi;
            else
                if defined? leading then
                    Pattern#quote(leading) ^ reg
                else
                    reg;
                fi;
            fi);
        Text tx:
           (Pattern#quote(tx));
        _ : failWith "should not happen";
        esac
    done
    |> strJoin "";
    
    regex = if strEnds? pat "/*" then
        reg ^ '(?:/(?<rest>.*))?'
    else
        reg
    fi;
    regex);

_nameMatchAll = matchAll '\?\<([A-Za-z0-9]+)\>' 
                        (Some . ((flip at) 1)) None;     

_regexRoute method regex handler  = 
   (import java.util.regex.Pattern;
    meth = strUpper method;
    var checkMethod? = meth != "ALL";
    
    names = _nameMatchAll regex |> catSome;
    pattern = Pattern#compile(regex);

    do req res:
        if checkMethod? and (meth != (strUpper req.method )) then
            res _sContinue;
        else
            matcher = pattern#matcher(req.path is string);
            if matcher#matches() then
                //add the paramters
                params = copy req.params;
                urlParams = array [];
                for [0..matcher#groupCount()] do c:
                    push urlParams matcher#group(c);
                done;
                params["urlPrams"] := list urlParams;
                
                //add the named parameters
                for names do name:
                    ls = if name in params then
                            params[name];
                         else
                            []
                         fi;
                    try
                        v = matcher#group(name);
                        if defined? v and strLength (string v) > 0 then
                            params[name] := v :: ls;
                        fi;
                    catch IllegalArgumentException ex:
                        println 
                            "matcher for regex \(regex) has not name \(name)";
                    yrt;        
                done;

                nreq = req with { params};

                try
                    handler nreq res
                catch ValidationException ex:
                    res _sContinue;
                yrt;
            else
                res _sContinue;
            fi;
        fi;
    done);

/**
 * Mounts the request to the given prefix
 * sets the mountPath the path and the url to the given value
 */
mount mountPrefix handler req response is string -> route -> route = 
    (if strStarts? req.path mountPrefix then
        nreq = req with {
            mountPath = req.mountPath^mountPrefix,
            path = strRight req.path (strLength mountPrefix)
        };
        handler nreq response
    else
        response _sContinue
    fi);

_methodPattern requestUrl = 
    case requestUrl of
    Get us: pair "GET" us;
    Post us: pair "POST" us;
    Put us: pair "PUT" us;
    Delete us: pair "DELETE" us;
    Options us: pair "OPTIONS" us;
    Head us: pair "HEAD" us;
    All us: pair "ALL" us;
    General {method, pattern} : pair method pattern;
    esac;


/**
 * Handleradapter which takes a request method and a regexpattern and 
 * executes on match the given route. 
 * Normally this is not used directly but a router is used.
 *
 */
regexRoute regex route =
    (pa = _methodPattern regex;
    _regexRoute pa.fst pa.snd route);

/**
 * RouteAdapter which takes a request method and a pattern 
 * (see patternToRegex) and 
 * executes on match the given route. 
 * Normally this is not used directly but a router is used.
 */
patternRoute pattern route =
    (pa = _methodPattern pattern;
    _regexRoute pa.fst (patternToRegex pa.snd) route);

/**
 * Creates one route from many routes. The routes are executed
 * one ofter the other as long as they respons with status-code 
 * the internal status-code continue (= -1)
 */
routes handlers req responder is list<route> -> route =
    if empty? handlers then
        responder _sContinue;
    else
        try
        (head handlers) req \case of
            None ex: responder (None (ex is ~Exception));
            Some res:
                if res.statusCode == continue.statusCode then
                    routes (tail handlers) req responder;
                else
                    responder (Some res)
                fi
            esac;
        catch Exception ex:
            responder (None ex);
        yrt
    fi;

/**
 * Parses the query and form data in queryParams and bodyParams
 */
paramsMiddleware route req res =
    (//the query
    cut = strIndexOf req.uri "?" 0;
    req = if cut >= 0 then
            req with {
                queryParams = parseQuery (strRight req.uri cut)
            }
        else
            req
        fi;
    //the form data
    req = req with {
        bodyParams = util.readFormData req
    };

    route req res);

/**
 * Cookie parser parses the cookies 
*/
cookiesMiddleware route req res =
    (nreq = req with {
        cookies = util.parseCookies req
    };
    route nreq res);

/**
 * Error handler
 */
errorMiddleware handler route req res =
    try
        route req \case of
        None ex: handler (ex is ~Exception) req res;
        Some r : res (Some r);
        esac;
    catch Exception ex:
        handler ex req res;
    yrt;

/**
 * Condition middleware 
 */
ifReq fn route req res =
    if fn req then
        route req res
    else
        res _sContinue
    fi;

/**
 * calculates the etag and set the header
 */
etagMiddleware route req resF =
    route req \case of
        None ex: resF (None ex);
        Some res:
            etag = messageByteDigest "MD5" res.body;
            case maybeAt None Some "If-None-Match" req.headers of
            None _: 
                res.headers["ETag"] := array [etag];
                resF (Some res);
            Some et:
                if et == etag then
                    resF (Some (response 304 [:] (toUTF8bytes "Not modified")))
                else
                    res.headers["ETag"] := array [etag];
                    resF (Some res);
                fi
            esac;
        esac;
{
    (==>>) = patternRoute,
    (~~>>) = regexRoute,
    (==>) p h = patternRoute p do req res:
        try res (Some (h req)) catch Exception ex: res (None ex) yrt
    done,
    (~~>) p h = regexRoute p do req res:
        try res (Some (h req)) catch Exception ex: res (None ex) yrt
    done,

    (<==) fn res is (either<response> -> ()) -> response -> ()= 
        fn (Some res),

    (@) text = escape text,

    response,
    continue,
    request,
    escape,
    patternToRegex,
    mount,
    regexRoute,
    patternRoute,
    routes,
    paramsMiddleware,
    cookiesMiddleware,
    errorMiddleware,
    ifReq,
    etagMiddleware
}
