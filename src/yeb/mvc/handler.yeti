/*
 * Copyright 2011 Christian Essl
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 */

module yeb.mvc.handler;



import java.lang: Thread, System, 
				  ClassLoader, Character, CharSequence,
				  Runnable;
import java.util: Locale, Date, Collection;
import java.util.regex:Pattern;
import java.util.concurrent.ConcurrentHashMap;
import java.text:NumberFormat, DecimalFormat, DateFormat, SimpleDateFormat;
import java.net: URLEncoder, URLDecoder;
import java.io:File;

import yeti.lang: Fun, Struct;
import org.yeb:ValidationException, YebUtils;

load yeb.std;
load yeb.async;
load yeb.mvc.webutils;
load yeb.validation;


//HandlerAdapters




/**
 * Transform an url pattern to a regex. Patterns are used in routers to 
 * specify path pattern which should be handled.
 *
 * ie for the pattern:
 * :/entry/:id/:date
 * becomes the regex
 * :/entry/([^/]+)/([^/]+)/(.*)
 * and the matched parts are exposed as request-parameters
 *
 * to specify a custom regex put it between $ $ after the name of the part.
 * ie to specify that id should only contain digits:
 * :/entry/:id$d+$
 */
urlPatternToRegex pat = 
   (//:a-z is name
    //:a-z? is optional
    //* at end means rest
    //$marks start regex $ marks end regex
    
    import java.util.regex.Pattern;
    
    paS = if strEnds? pat "/*" then 
                    strLeft pat (strLength pat - 2)
               else
                    pat;
               fi;
               
    tokens = matchAll '(/?\.?):(\w+)(\$([^\$]+)\$)?(\?)?' (Token . tail) Text paS;
    
    names = tokens 
        |> map do t:
            case t of
            Token [leading, name, foo, regex, mark]: Some name;
            _ : none;
            esac
        done
        |> catSome
        |> array;
    
    reg = tokens
    |> map do x:
        case x of
        Token [leading, name, foo, regex, mark]:
           (reg = if defined? regex and (strLength regex > 0) then 
                    regex;
                  else
                    '[^/\.]+'
                  fi;
            reg2 = "(?<\(name)>\(reg))";
            
            if defined? mark then
                if defined? leading then
                    "(?:\(Pattern#quote(leading))" ^ reg2 ^ ")?" ;
                else
                    reg2 ^ "?";
                fi;
            else
                if defined? leading then
                    Pattern#quote(leading) ^ reg2
                else
                    reg2;
                fi;
            fi);
        Text tx:
           (Pattern#quote(tx));
        _ : failWith "should not happen";
        esac
    done
    |> strJoin "";
    
    regex = if strEnds? pat "/*" then
        push names "rest";
        reg ^ '(?:/(?<rest>.*))?'
    else
        reg
    fi;
    
    {
        names = nub names,
        regex
    }
    );

    

regexHandlerImpl method regexPattern handler  = 
   (import java.util.regex.Pattern;
    meth = strUpper method;
    var checkMethod? = meth != "ALL";
    
    {names, regex} = urlPatternToRegex regexPattern;
    pattern = Pattern#compile(regex);

    do req res:
        if checkMethod? and (meth != (strUpper req.method )) then
            res continue;
        else
            matcher = pattern#matcher(req.path is string);
            if matcher#matches() then
                //add the paramters
                params = copy req.params;
                urlParams = array [];
                for [0..matcher#groupCount()] do c:
                    push urlParams matcher#group(c);
                done;
                params["urlPrams"] := list urlParams;
                
                //add the named parameters
                for names do name:
                    ls = if name in params then
                            params[name];
                         else
                            []
                         fi;
                    params[name] := (string matcher#group(name)) :: ls;
                done;

                //set the new pathInfo and servletPath
                path = if (contains? "rest" names) 
                    and (defined? matcher#group("rest")) then
                    string matcher#group("rest");        
                else
                    ""
                fi;
                nreq = req with { params, path};

                handler nreq res
            else
                res continue;
            fi;
        fi;
    done);

/**
 * Handleradapter which takes a request method and path pattern and 
 * executes on match the given handler. 
 * Normally this is not used directly but a router is used.
 * The path pattern is the same as described in urlPatternToRegex.
 *
 * to handle the Get request for index:
 * :regexHandler (Get "index") do ctxt: ....; Completed "" done;
 */
regexHandler requestUrl handler = 
   ({fst = meth , snd = regexPattern} = 
        case requestUrl of
        Get us: pair "GET" us;
        Post us: pair "POST" us;
        Put us: pair "PUT" us;
        Delete us: pair "DELETE" us;
        Options us: pair "OPTIONS" us;
        Head us: pair "HEAD" us;
        All us: pair "ALL" us;
        General {method, pattern} : pair method pattern;
        esac;
    regexHandlerImpl meth regexPattern handler);
    
runHandlers handlers req responder is list<handler> -> handler =
    if empty? handlers then
        responder continue;
    else
        try
        (head handlers) req \case of
            None ex: responder (None (ex is ~Exception));
            Some res:
                if res.statusCode == continueStatusCode then
                    runHandlers (tail handlers) req responder;
                else
                    responder (Some res)
                fi
            esac;
        catch Exception ex:
            responder (None ex);
        yrt
    fi;

/**
 * Converts the request parameters to a struct. 
 * The parameters of the request are converted to a struct. Parametes starting
 * with 'num_' are converted to number values, witho "bool_" to boolean-values.
 * The 'num_' and 'bool_' values are stripped of the name.
 *
 * If the request has content-type "form-url-encoded" than the body is also
 * added to the parameters. If the content-type is "application/json/ then
 * the body is converted to a JsonObject and added as "body" to the struct.
 *
 * The resulting struct is set as values field on the request struct and
 * than the given handler is called.
 *
 * The optional special parameter '_function' is set as functionName on to
 * the request-struct. It is not part of values struct.
 *
 * Arguments:
 * options - defaultValues and/or default funcitonName
 * handler - handler to call with the result
 */
requestToStruct opts nextHandler is 'o -> 'h -> handler =
    (load yeb.validation;
    yvertx = load yvertx;

    values = [:];
    var functionName = "";
    for opts \case of
        Defaults ha: insertHash values (ha is hash<string,list<string>>);
        DefaultFunction n: functionName := n;
    esac;

    do req res:
        import org.vertx.java.core.json:JsonObject,
                                        JsonArray;
        import org.vertx.java.core.eventbus:Message;
        
        readFormData req;

        insertHash values req.params;


        jo = new JsonObject();
        forHash values do k v:
            _ = if strStarts? k "num_" then
                name = strRight k 4;
                value = valiList strToNum (req.params[k]);
                if length value == 1 then
                    jo#putNumber(name, (head value) is number);
                else
                    ja = new JsonArray();
                    for value do v:
                        _ = ja#add(v);
                    done;
                    jo#putArray(name, ja);
                fi;
            elif strStarts? k "bool_" then
                name = strRight k 5;
                value = valiList strToBoolean (req.params[k]);
                if length value == 1 then
                    jo#putBoolean(name, head value);
                else
                    ja = new JsonArray();
                    for value do v:
                        _ = ja#add(v);
                    done;
                    jo#putArray(name, ja);
                fi;
            elif k == "_function" and
                length (req.params[k]) > 0 then
                functionName := head req.params[k];
            else
                name = k;
                value = req.params[k];
                if length value == 1 then
                    jo#putString(name, head value);
                else
                    ja = new JsonArray();
                    for value do v:
                        _ = ja#add(v);
                    done;
                    jo#putArray(name, ja);
                fi;
            fi;
        done;

        if "Content-Type" in req.headers
            and req.headers["Content-Type"] =~ "application/json" then
            //read the body and parse it as jons
            json = new JsonObject(fromUTF8 req.body);
            jo#putObject("body",json);
        fi;


        result = {functionName,
                values = yvertx.fromJS jo};
        nextHandler req result res;
        
   done); 

/**
 * creates a handler which converts the request to struct using
 * the 'requestToStruc' function and than invoces a function on the given
 * structure according to the name with the value.
 */
jsonStructAdapter opts stru is 'a -> {jsonStru is boolean} -> handler =
    (import yeti.lang:Fun;
    fnHash = (
        ret = [:];
        {fields, value} = case peekObject stru of
            Struct r: r;
            _ : failWith "this is not realy possible"
        esac;
        
        fields 
            |> filter do fin:
                fold do b n: b or (strStarts? fin n) done 
                    false 
                    ["get_", "put_", "post_", "delete_", "all_"]
            done
            |> (flip for) do n:
                case value n of
                Object ob: 
                    if (ob is ~Object) instanceof Fun then
                        ret[n] := (ob unsafely_as ~Fun)
                    fi;
                _ : ()
                esac;
            done;
        ret);
    
    requestToStruct opts do req {functionName, values} res:
        {method} = req;
        sname = (strLower method)^"_"^functionName;
        
        call fno = 
            (fn = (fno is ~Object) unsafely_as ('a -> 'b);
            js = fn values;
            js = js with {for_json = E()};
            res (writeJsonResponse (req as request) js));
             

        if sname in fnHash then
            call fnHash[sname];
        else
            sname = "all_"^functionName;
            if sname in fnHash then
                call fnHash[sname]
            else
               res continue; 
            fi
        fi;
        
    done);

/**
 * Loads a handler from a module by name
 */
lazyHandler moduleName  is string -> handler =
   (var myHandler is (Some handler | None () ) = none;
    loadHandler () = (
        cl = Thread#currentThread()#getContextClassLoader()#loadClass(moduleName);
        mod = cl#getMethod(
            "eval",() as ~Class[])#invoke(() as ~Object, () as ~Object[]);
        jmod = mod unsafely_as {handler is handler};
        h = jmod.handler;
        myHandler := Some h;
        h;
    );
    if not ((load yeb.mvc.config).webDynamicReload?) then
        loadHandler();
    else
        do ctxt:
            ha = case myHandler of
                Some h: h;
                None _ : loadHandler ();
            esac;
            ha ctxt;
        done;
    fi);

_routerFact oldVhs = 
   (vhs = array [];
    {
        add handler =
            push vhs handler,
        
        handle regex handler = add ((regexHandler regex) handler),

        convert regex handler = 
            add ((regexHandler regex) (requestToStruct [] handler)),  

        jsonStruct regex opts stru = 
            add (regexHandler (All regex) (jsonStructAdapter opts stru)),

        //lazy regex moduleName = 
        //    add ((regexHandler (All regex)) (lazyHandler moduleName)),

        newHandler () =
            runHandlers (vhs ++ oldVhs),

        newSubRouter () =
            _routerFact (vhs ++ oldVhs),
    });
    
/**
 * Creates a router. A router is used to handle different requests.
 *
 * ie to specify differen request handlings do:
 * :router = newRouter id;
 * :router.get "index" do req res: //handle get request done
 * :router.post "someform" do req res: //handle post request done
 * :router.add customHandler; //use to add a handler which is always executed
 * :
 * :handler = router.newHandler; //cunstructs an handler for all the routes
 *
 * The router will than try to match any route in the order given and execute
 * the handlerfunction if it fits.
 *
 * Each handler function must return either 
 * - Completed if the request was handled by this handler and the async Request
 *   context can be closed 
 * - NotHandled "" if the reuqest is not handled by this handler and the next 
 *   routes/handlers should be tried to match
 * - Handling "" means that the right handler was found but the async RequestContext
 *   is kept open for further processing by the handler
 *
 * The router creates itself a handler with .newHandler. This handler can be used
 * directly in yebWebMain.handler or can be given to another router (with .add)
 * 
 * The adapter parameter is a function whith transforms each given handler to 
 * another handler. This adapter can be used to filter each request 
 *
 * ie to make sure each request is of a certain locale and has a logged in user:
 * 
 */
 
newRouter () = _routerFact [];


/**
 * Takes a yebhandler and creates a vertx HttpHandler.
 * used to Brigde between Vertx http and yeb.
 */
yebHandlerToVertxHandler opts yebhandler =
    (import org.vertx.java.core.http:HttpServerRequest;
    load yvertx;
    fileHandler = serveStaticFileAtPath opts;
    do reqO:            
        bodyHandler (reqO is ~HttpServerRequest) do buffer:
            
            req = {
                headers = requestHeaders reqO,
                uri = reqO#uri,
                path = reqO#path,
                method = reqO#method,
                params = 
                    ret = [:];
                    forHash (params reqO) do k v: ret[k]:=[v] done;
                    ret,
                body = buffer#getBytes(),
                resHeaders = [:],
            } is request;
            try
                (yebhandler is handler) req 
                    \case of
                    None ex:
                        reqO#response#statusCode := 404;
                        _ = reqO#response#end();
                        throw (ex is ~Exception);
                    Some res: 
                        if res.statusCode == continueStatusCode then
                            reqO#response#statusCode := 404;
                            _ = reqO#response#end();
                        elif res.statusCode == -2 then
                            path = res.headers["file"];
                            fileHandler path reqO;
                        else
                            reqO#response#statusCode := res.statusCode;
                            putResponseHeaders reqO [:]; // res.headers;
                            if not res.body == noneBody then
                                reqO#response#write(newByteBuffer res.body);
                            fi;
                            _ = reqO#response#end();
                        fi;
                    esac;
            catch Exception ex:
                reqO#response#statusCode := 404;
                _ = reqO#response#end();
                throw (ex is ~Exception);
            yrt;
        done
    done);

/**
 * Creates an  yebHandler which fans out to many vertx workers yebHandlers.
 * Takes a factory function which produdes handlers and returns an
 * async function from which one yebhandler can be gotten. This handler will
 * fan out its request to the handler produced by the factory function
 */
createRequestWorkers numberOfWorkers yebHandlerFactoryFn = 
    (load yeb.async;
    load yvertx;

    fibre = newFibre();

    [1 .. numberOfWorkers]
    |>map' \(newWorker 
        \(handler is handler = yebHandlerFactoryFn ();
        _ = fibre.register do {req,res}: handler req res done;
        ))
    |>parallel 
    |>bind \(return do req res:
        fibre.send {req, res};
    done));

/**
 * Creates a VertxHttpHandler which bridges to a number of worker
 * yebHandlers
 */
createYebHttpServer timeOutMs httpOpts numberOfWorkers yebHandlerFactoryFn =
    (load yeb.async;
    load yvertx;

    createRequestWorkers numberOfWorkers yebHandlerFactoryFn
        |> bind (return . yebHandlerToVertxHandler httpOpts)
        |> await timeOutMs
        |> createHttpServerWithHandler);

/*
requestToJson req = 
    {headers = (req is request).headers,
    uri = req.uri,
    path = req.path,
    method = req.method,
    params = req.params,
    resHeaders = req.resHeaders,
    body = req.body,
    for_json = E()};
    
requestToBusHandler bustarget req =
    (yvertx = load yvertx;
    jr = requestToJson req;
    yvertx.requestFromBus bustarget jr do r:
        res = case r of
        None ex:
            response req 404 [:] noneBody;
        Some m:
            response req
                (maybeDefined \200 isNumber m.statusCode)
                (maybeDefined \[:] id m.headers)
                (maybeDefined \noneBody id m.body);
        esac is response;
        (req is request).respond res;
    done);

requestFromBusHandler handler msg =
    (b = msg.body;
    (handler is handler) {
        headers = maybeDefined \[:] id b.headers,
        uri = isString b.uri,
        path = isString b.path,
        method = isString b.method,
        params = maybeDefined \[:] id b.params,
        body = maybeDefined \noneBody id b.body,
        resHeaders = maybeDefined \[:] id b.resHeaders,
        respond res = msg.reply (Some  res)
        });
*/
(load yeb.mvc.webutils) with {

    urlPatternToRegex,

    regexHandler,
    
    newRouter,

    requestToStruct,
    
    yebHandlerToVertxHandler, 
    createRequestWorkers,

    createYebHttpServer,

}

