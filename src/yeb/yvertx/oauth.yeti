/*
 * Copyright 2011 Christian Essl
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 */


module yeb.yvertx.oauth;

load yeb.std;

mvc = load yeb.mvc.mvc;

typedef credentials = {secret is string,
                       key is string};
                       



authentication consumerAuth userAuth is 
    credentials -> credentials -> 'a -> 'b =
    (
    //constantcs
    authorization = "Authorization";
    oauth_consumer_key = "oauth_consumer_key";
    oauth_nonce = "oauth_nonce";
    oauth_signature = "oauth_signature";
    oauth_signature_method = "oauth_signature_method";
    oauth_timestamp = "oauth_timestamp";
    oauth_token = "oauth_token";
    oauth_version = "oauth_version";

    oauth_version_1_0 = "1.0";
    signature_method = "HMAC-SHA1";
    
    //threadsave digesting function
    macDigester = 
        (import javax.crypto: Mac;
        import javax.crypto.spec: SecretKeySpec;

        keyBytes = toUTF8bytes (consumerAuth.secret ^"&"^userAuth.secret);
        signingKey = new SecretKeySpec(keyBytes, "HmacSHA1");
        mac = Mac#getInstance("HmacSHA1");
        mac#init(signingKey);
        mutex = new Object();
        do message:
            synchronized mutex 
                \(mac#reset();
                mac#doFinal(message is ~byte[]));
        done);
    
    //random generator
    random = new java.util.Random(
        System#identityHashCode(obj macDigester)
        + System#currentTimeMillis());
    
    //the actual function
    do {method, hostPort, path, formParams, request, client}: 
        import java.lang.StringBuilder;

        //split path form query params
        {path, queryParams} = 
            (cut = strIndexOf path "?" 0;
            if cut < 1 then
                {path = path, queryParams = [:]}
            else
                path = strLeft path cut;
                query = strRight path cut;
                {path, queryParams = mvc.parseQuery query}
            fi);

        //construct base url (http(s)+hostPort+path)
        import org.vertx.java.core.http.HttpClient;
        baseURL = if not (client is ~HttpClient)#isSSL() then
                "http://" ^ if strEnds? hostPort ":80" then
                        strLeft hostPort (strLength hostPort - 3);
                    else
                        hostPort
                    fi
                else 
                    "https://" ^ if strEnds? hostPort ":443" then
                        strLeft hostPort (strLength hostPort - 4);
                    else
                        hostPort
                    fi
                fi;
        baseURL = baseURL ^ if strStarts? path "/" then 
                        path
                    else
                        "/"^path
                    fi;

        //timestamp an nonce
        oauthTimestamp = System#currentTimeMillis() / 1000;
        nonce = 
            (nonceBuffer = new byte[16];
            random#nextBytes(nonceBuffer);
            toBase64 nonceBuffer);
        
        //the signuature
        signature = 
            (signedText = new StringBuilder(100);
            _ = signedText#append(strUpper method)#append("&");
            

            signedText#append(urlEncode baseURL);

            allParameters = [:];
            
            allParameters[oauth_consumer_key] := consumerAuth.key is string;
            allParameters[oauth_nonce] := nonce is string;
            allParameters[oauth_signature_method] := signature_method;
            allParameters[oauth_timestamp] 
                := string (oauthTimestamp is number);
            allParameters[oauth_token] := userAuth.key;
            allParameters[oauth_version] := oauth_version_1_0;

            forHash formParams do key values:
                for values do value:
                    allParameters[key] := value;
                done;
            done;

            forHash queryParams do key values:
                for values do value:
                    allParameters[key] := value;
                done;
            done;
            
            //sort all parameters, encode and join them
            encodedParams = allParameters 
                |> mapHash do k v:
                    pair (urlEncode k) (urlEncode v)
                done
                |> sortBy do {fst, snd} {fst = f2, snd = s2}:
                    if fst == f2 then
                        snd < s2
                    else
                        fst < f2
                    fi;
                done
                |> map do {fst,snd} : fst^"="^snd done
                |> strJoin "&";

            _ = signedText#append("&")
                #append(urlEncode encodedParams);
        
            signatureBytes = 
                macDigester (toUTF8bytes (signedText#toString()));
            toBase64 signatureBytes);

        headerValue = "OAuth \(oauth_consumer_key)=\"\(consumerAuth.key)\", "
            ^"\(oauth_token)=\"\(userAuth.key)\", "
            ^"\(oauth_signature_method)=\"\(signature_method)\", "
            ^"\(oauth_signature)=\"\(urlEncode signature)\", "
            ^"\(oauth_timestamp)=\"\(string oauthTimestamp)\", "
            ^"\(oauth_nonce)=\"\(urlEncode nonce)\", "
            ^"\(oauth_version)=\"\(oauth_version_1_0)\"";
        
        import org.vertx.java.core.http:HttpClientRequest;
        _ = (request is ~HttpClientRequest)
                #putHeader(authorization, headerValue);
    done);
{
    authentication
}
    
    


