/*
 * Copyright 2011 Christian Essl
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 */

module yvertx.fs;

                 
import java.util.Map;                 

import org.vertx.java.core: Handler, Vertx;
import org.vertx.java.core.buffer: Buffer;
import org.vertx.java.core.file:FileSystem,
                                FileSystemProps,
                                FileProps,
                                AsyncFile;

yvertx = load yvertx;

_tarh = yvertx.helper.toTypedAsyncResultHandler;
_arh = yvertx.toAsyncResultHandler;

do vertx :
    fs = (vertx is ~Vertx)#fileSystem();
    {
    fileSystem = fs,
    chmod path perms handler =
        fs#chmod(path is string, perms is string, _arh handler),
    chmodDir path perms dirPerms handler =
        (fs)#chmod(path is string, perms is string, dirPerms is string,
                         _arh handler),
    copy from to recursive handler =
        (fs)#copy(from is string, to is string, 
                            recursive is boolean, _arh handler),

    createFile path perms handler =
        case perms of
        None _ :
            (fs)#createFile(path is string, _arh handler);
        Some perm:
            (fs)#createFile(path, perm is string, _arh handler);
        esac,
    delete path recursive handler =
        (fs)#delete(path is string, recursive is boolean, _arh handler),

    exists path handler =
        (fs)#exists(path is string, _tarh (unsafely_as boolean) handler),
        
    fsProps path handler =
        (fs)#fsProps(path is string, 
                            _tarh (unsafely_as ~FileSystemProps) handler),
    link link existing handler =
        (fs)#link(link is string, existing is string, _arh handler),
     
    lprops path handler =
        (fs)#lprops(path is string, 
                            _tarh (unsafely_as ~FileProps) handler),

    mkdir path perms createParents handler =
        case perms of
        None _ : 
            (fs)#mkdir(path is string, 
                              createParents is boolean, _arh handler);
        Some perm:
            (fs)#mkdir(path is string, perm is string, 
                              createParents is boolean, _arh handler);
        esac,

    move from to handler =
        (fs)#move(from is string, to is string, _arh handler),

    props path handler =
        (fs)#props(path is string, 
                        _tarh (unsafely_as ~FileProps) handler),
        
    readDir path filter handler =
       (mfn obj = map string (wrapArray ((obj is ~Object) 
                                    unsafely_as ~String[]));
        case filter of
        None _:
            (fs)#readDir(path is string, _tarh mfn handler);
        Some fil:
            (fs)#readDir(path is string, 
                                fil is string, _tarh mfn handler);
        esac),

    readFile path handler =
        (fs)#readFile(path is string, 
                            _tarh (unsafely_as ~Buffer) handler),

    readSymlink path handler =
        (fs)#readSymlink(path is string, 
                                _tarh (unsafely_as string) handler),
        
    symlink link existing handler =
        (fs)#symlink(link is string, existing is string, _arh handler),
    truncate path len handler =
        (fs)#truncate(path is string, len is number, _arh handler),

    unlink link handler =
        (fs)#unlink(link is string, _arh handler),

    writeFile path data handler =
        (fs)#writeFile(path is string, data is ~Buffer, _arh handler),

    open opts path handler =
       (var createNew = true;
        var flush = false;
        var read = true;
        var write = true;
        var perms = () as ~String;
        for opts do opt:
            case opt of
            CreateNew b : createNew := b;
            Read b: read := b;
            Write b: write := b;
            Flush b: flush := b;
            Perms s: perms := s;
            esac
        done;
        
        (fs)#open(path is string, perms, read, write, createNew,
                              flush, _tarh (unsafely_as ~AsyncFile) handler)),

    closeAFile file handler =
        (file is ~AsyncFile)#close(_arh handler),

    flushAFile file handler =
        (file is ~AsyncFile)#flush(_arh handler),

    readAFile file buffer offset position length handler =
        (file is ~AsyncFile)#read(buffer is ~Buffer, offset is number,
                                  position is number,
                                  length is number,
                                  _tarh (unsafely_as ~Buffer) handler),

    writeAFile file buffer position handler =
        (file is ~AsyncFile)#write(buffer is ~Buffer, position is number,
                                   _arh handler),
    }
done;
