module yvertx.cb;

import java.lang:Exception;

typedef cbrType<a> = Some a | Exception ~Exception;
typedef cbType<a> = cbrType<a> -> ();
typedef cbfnType<a> = cbType<a> -> ();


cbId v = do cb: cb v done;

cbBind fn cbfn is ('a -> cbfnType<'b>) -> cbfnType<'a> -> cbfnType<'b>= 
    do cb:
        cbfn \case of
            Exception ex: cb (Exception ex);
            Some v: (fn v) \case of
                    Exception ex: cb (Exception ex);
                    Some v: cb (Some v);
                    esac;
            esac;
    done;

cbFlatten cbfn is cbfnType<cbfnType<'a>> -> cbfnType<'a>
    = cbBind id cbfn;

cbMap fn cbfn is ('a -> 'b) -> cbfnType<'a> -> cbfnType<'b>=
    do cb:
        cbfn \case of
            Exception ex : cb (Exception ex);
            Some v: cb (Some (fn v));
            esac;
    done;

cbLift fn cb a is ('a -> 'b) -> ('a -> cbfnType<'b>)=
    cb (fn a);
    
cbSeq cbfns cb =
    (var called = false;
     res = array [];
     for cbfns do c:
        c \case of
            Exception ex: 
                if not called then
                    called := true;
                    cb (Exception ex);
                    called := true;
                fi;
            Some v:
                if not called then
                    push res v;
                    if length res == length cbfns then
                        called := true;
                        cb (Some (list res));
                    fi
                fi
            esac;
    done);

cbStruTH = threadLocal none;

cbSet cbfn =
    (ctr = case cbStruTH.value of
            None _ : failWith "not in cbStru function";
            Some v : v;
           esac;
    ctr.starting();
    var hasReceived = false;
    var res = NotSet ();
    cbfn \case of
        Exception ex: 
            (res := Exception (ex is ~Exception);
             ctr.exception(ex));
        Some v: 
            (res := Some v;
            if not hasReceived then
                ctr.hasReceived();
                hasReceived := true
            fi);
        esac;
    \(res));    

cbStru inex cb =
    (var called = false;
     var requests = 0;
     var received = 0;
     var result = none;
     ctr = {
        starting () = 
            requests := requests + 1,
        exception ex =
            if not called then
                called := true;
                cb (Exception (ex is ~Exception));
            fi,
        hasReceived () =
            received := received + 1;
            if not called then
                case result of
                None _ : ();
                Some v: 
                    if received == requests then
                        called := true;
                        cb v;
                    fi;
                esac;
            fi,
    };
    try 
        cbStruTH.value := Some ctr;
        r = inex ();
        result := Some r;
        if not called and received == requests then
            called := true;
            cb r
        fi;
            
    catch Exception ex:
        if not called then
            called := true;
            cb (Exception ex);
        fi
    finally
        cbStruTH.value := none;
    yrt;
    ());

cbRun exfn =\case of
    Exception ex: exfn ex;
    Some (): ();
    esac;

ief efn fn = \case of
    None ex: efn ex;
    Some v : fn v;
    esac;

ie fn = ief id;


{
    cbId,
    cbBind,
    cbFlatten,
    cbMap,
    cbLift,
    cbSeq,
    cbSet,
    (->) cbfn fn =  cbMap fn cbfn,
    (->>) cbfn fn = cbBind fn cbfn,
    ie

}
