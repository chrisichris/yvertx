module yvertx.webServer;

import java.io:File;
import org.vertx.java.core.http:HttpServerRequest,
                                 RquestMatcher;
import org.vertx.java.core.http.impl:HttpReadStreamBase;
import org.vertx.java.core.file.impl.PathAdjuster;
import org.vertx.java.deploy.Verticle;
import org.vertx.java.busmods.BusModBase;

load yvertx;
load yeb.std;

staticFileConf = {
    web_root = "web",
    gzip_files = false,
    index_page = "index",
};

serveStaticFile conf req =
    serveStaticFileAtPath [
        WebRoot conf.web_root,
        IndexPage conf.index_page,
        Gzip conf.gzip_files] 
        req req#path;



bridgeRequest conf bustarget reqO =
    bodyHandler (reqO is ~HttpServerRequest) do buffer:
        headers = 
            (ret = [:];
            forHash (requestHeaders (reqO is ~HttpServerRequest)) do k v:
                ret.[k] := [v];
            done;
            ret);
                
        req = {
            headers,
            uri = reqO#uri,
            method = reqO#method,
            path = reqO#path,
            query = reqO#query,
            params = params reqO,
            body = buffer#getBytes(),
            for_json = E()};
        
        requestBody bustarget req 
            \case of
            Exception ex:
                (reqO#response#statusCode := 404;
                _ = reqO#response#end();
                ());
            Some body:
                (res = body;
                reqO#response#statusCode := 
                    maybeDefined \200 isNumber res.status;
                
                _ = if defined? res.statusMessage then
                    reqO#response#statusMessage := string res.statusMessage
                fi;
                
                if defined? res.headers then
                    putResponseHeaders reqO res.headers
                fi;
                
                if defined? res.file then
                    serveStaticFileAtPath [
                        WebRoot conf.web_root,
                        IndexPage conf.index_page,
                        Gzip conf.gzip_files] 
                        reqO
                        (string res.file);
                elif defined? res.body then
                    reqO#response#write(newByteBuffer res.body);
                    reqO#response#end();
                fi;
                ());
            esac;
    done;


proxyRequest proxyTo = 
    (client = createHttpClient proxyTo;
    do req:
        cReq = httpRequest client
            (Request {method = (req is ~HttpServerRequest)#method, 
                      uri = req#uri}) 
            [:]
            do cRes:
                req#response#statusCode := cRes#statusCode;
                req#response#headers()#putAll(cRes#headers());
                req#response#setChunked(true);
                dataHandler cRes do data:
                    _ = req#response#write(data);
                done;
                endHandler cRes do:
                    req#response#end()
                done;
            done;
        cReq#headers()#putAll(req#headers());
        cReq#setChunked(true);
        dataHandler req do buffer:
            _ = cReq#write(buffer);
        done;
        endHandler req do: cReq#end() done;
    done);

serverConf = staticFileConf with {
    port = 80,
    host = "0.0.0.0",
    ssl = false,
    key_store_password = "wibble",
    key_store_path = "server-keystore.jks",
    static_files = true,
    bridge = false,
    inbound_permitted = [],
    outbound_permitted = [],
    sjs_config = {prefix = "/eventbus"},
    auth_timeout = 5 * 60 * 1000,
    auth_address = "vertx.basicauthmanager.authorise",
    routes = [],
};

startServer conf =
    (server = createHttpServer ();
    if not empty? conf.routes or conf.static_files then
        rm = newRouteMatcher();

        //add the static file handler
        if conf.static_files then
            _ = rm.noMatch (serveStaticFile conf);
        fi;
        for conf.routes do route:
            handler = case route.type of
            "proxy":
                proxyRequest route.host_port;
            "request" : 
                bridgeRequest conf route.bus_target;
            x : failWith "unknown type \(x) on route \(route.pattern)";
            esac;
            rm.route route.pattern handler;
        done;
    fi;

    if conf.ssl then
        _ = server#setSSL(true)
            #setKeyStorePassword(conf.key_store_password)
            #setKeyStorePath(conf.key_store_path);
    fi;

    if conf.bridge then
        sjsServer = createSockJSServer server; 
        bridgeSockJS sjsServer [AuthTimeout conf.auth_timeout,
                          AuthAddress conf.auth_address]
                        (conf.sjs_config with emptyJS)
                        conf.inbound_permitted 
                        conf.outbound_permitted;
    fi;
    _ = server#listen(conf.port,conf.host));

    

class WebServer extends Verticle

    void start()
        conf = blend serverConf (config ());
        startServer conf,
end;

{
    staticFileConf,
    serveStaticFileAtPath,
    serveStaticFile,
    bridgeRequest,
    proxyRequest,
    serverConf,
    startServer,
    verticle () = new WebServer()
}
