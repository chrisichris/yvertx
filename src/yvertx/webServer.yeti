module yvertx.webServer;

import java.io:File;
import org.vertx.java.core.http:HttpServerRequest,
                                 RquestMatcher;
import org.vertx.java.core.http.impl:HttpReadStreamBase;
import org.vertx.java.core.file.impl.PathAdjuster;
import org.vertx.java.deploy.Verticle;
import org.vertx.java.busmods.BusModBase;

load yvertx;

staticFileConf = {
    web_root = "web",
    gzip_files = false,
    index_page = "index",
};
serveStaticFileAtPath conf req path =
    (webRootPrefix = conf.web_root ^ File#separator;
    indexPage = webRootPrefix ^ conf.index_page;
    
    headers = requestHeaders req;
    acceptEncodingGzip = if "accept-encoding" in headers then
            strIndexOf headers.["accept-encoding"] "gzip" 0 > -1;
        else
            false
        fi;
    fileName = webRootPrefix ^ path;
    if path == "/" then
        req#response#sendFile(indexPage);
    elif strIndexOf path ".." 0 < 0 then
        if conf.gzip_files and acceptEncodingGzip then
            file = new File(PathAdjuster#adjust(fileName ^ ".gz"));
            if file#exists() then
                req#response#putHeader("content-encoding", "gzip");
                req#response#sendFile(fileName ^ ".gz");
            else
                req#response#sendFile(fileName);
            fi
        else
            req#response#sendFile(fileName);
        fi
    else
        req#response#statusCode := 404;
        req#response#end();
    fi;
    ());

serveStaticFile conf req =
    serveStaticFileAtPath conf req req#path;



bridgeRequest conf bustarget reqO =
    bodyHandler (reqO is ~HttpServerRequest) do buffer:
        req = {
            headers = requestHeaders (reqO is ~HttpServerRequest),
            method = reqO#method,
            path = reqO#path,
            query = reqO#query,
            uri = reqO#uri,
            params = params reqO,
            body = buffer#getBytes(),
            for_json = E()};
        
        requestBody bustarget req 
            \case of
            Exception ex:
                (reqO#response#statusCode := 404;
                _ = reqO#response#end();
                ());
            Some body:
                (res = body;
                reqO#response#statusCode := 
                    maybeDefined \200 isNumber res.status;
                
                _ = if defined? res.statusMessage then
                    reqO#response#statusMessage := string res.statusMessage
                fi;
                
                if defined? res.headers then
                    putResponseHeaders reqO res.headers
                fi;
                
                if defined? res.file then
                    serveStaticFileAtPath conf reqO (string res.file);
                elif defined? res.body then
                    reqO#response#write(newByteBuffer res.body);
                    reqO#response#end();
                fi;
                ());
            esac;
    done;


proxyRequest proxyTo = 
    (client = createHttpClient proxyTo;
    do req:
        cReq = httpRequest client
            (Request {method = (req is ~HttpServerRequest)#method, 
                      uri = req#uri}) 
            [:]
            do cRes:
                req#response#statusCode := cRes#statusCode;
                req#response#headers()#putAll(cRes#headers());
                req#response#setChunked(true);
                dataHandler cRes do data:
                    _ = req#response#write(data);
                done;
                endHandler cRes do:
                    req#response#end()
                done;
            done;
        cReq#headers()#putAll(req#headers());
        cReq#setChunked(true);
        dataHandler req do buffer:
            _ = cReq#write(buffer);
        done;
        endHandler req do: cReq#end() done;
    done);

serverConf = staticFileConf with {
    port = 80,
    host = "0.0.0.0",
    ssl = false,
    key_store_password = "wibble",
    key_store_path = "server-keystore.jks",
    static_files = true,
    bridge = false,
    inbound_permitted = [],
    outbound_permitted = [],
    sjs_config = {prefix = "/eventbus", for_json = E()},
    auth_timeout = 5 * 60 * 1000,
    auth_address = "vertx.basicauthmanager.authorise",
    routes = [],
    for_json=E(),
};

startServer conf =
    (server = createHttpServer ();
    if not empty? conf.routes or conf.static_files then
        rm = newRouteMatcher();

        //add the static file handler
        if conf.static_files then
            _ = rm.noMatch (serveStaticFile conf);
        fi;
        for conf.routes do route:
            handler = case route.type of
            "proxy":
                proxyRequest route.host_port;
            "request" : 
                bridgeRequest conf route.bus_target;
            x : failWith "unknown type \(x) on route \(route.pattern)";
            esac;
            rm.route route.pattern handler;
        done;
    fi;

    if conf.ssl then
        _ = server#setSSL(true)
            #setKeyStorePassword(conf.key_store_password)
            #setKeyStorePath(conf.key_store_path);
    fi;

    if conf.bridge then
        sjsServer = createSockJSServer server; 
        bridgeSockJS sjsServer [AuthTimeout conf.auth_timeout,
                          AuthAddress conf.auth_address]
                        conf.sjs_config 
                        conf.inbound_permitted 
                        conf.outbound_permitted;
    fi;
    _ = server#listen(conf.port,conf.host));

    

class WebServer extends Verticle

    void start()
        conf = blend serverConf (config ());
        startServer conf,
end;

{
    staticFileConf,
    serveStaticFileAtPath,
    serveStaticFile,
    bridgeRequest,
    proxyRequest,
    serverConf,
    startServer,
    verticle () = new WebServer()
}
