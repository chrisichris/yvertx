/*
 * Copyright 2011 Christian Essl
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 */

module yvertx.httpc;

                 
import java.util.Map;                 

import org.vertx.java.core: Handler, Vertx;
import org.vertx.java.core.http:HttpClientResponse,
                                HttpClientRequest,
                                WebSocket,
                                HttpClient;

yvertx = load yvertx;

toHandler = yvertx.toHandler;

bodyHandler response handler =
   (response is ~HttpClientResponse)#bodyHandler(
        yvertx.toBufferHandler handler);
   
create hostPort = 
   ({port,host} = yvertx.helper.hostAndPort hostPort; 
    (yvertx.vertx)#createHttpClient()#setPort(port)#setHost(host));

putHeaders request headers =
   ((request is ~HttpClientRequest)#headers()#putAll(
        (headers is hash<string,string>) as ~Map);
    request);
    
request client muri headers handler =
    (h = toHandler (handler . (unsafely_as ~HttpClientResponse));
    req = case muri of
    Connect uri: 
        (client is ~HttpClient)#connect(uri is string, h);
    Delete uri:    
        client#delete(uri is string, h);
    Get uri: 
        client#get(uri is string, h);
    Head uri:
        client#head(uri is string, h);
    Options uri:
        client#options(uri is string, h);
    Patch uri:
        client#patch(uri is string, h);
    Put uri:
        client#put(uri is string, h);
    Post uri:
        client#post(uri is string, h);
    Trace uri:
        client#trace(uri is string, h);
    Request {method, uri}:
        client#request(method is string, uri is string, h); 
    esac;
    putHeaders req headers);

getNow client uri headers handler =
   (client is ~HttpClient)#getNow(uri is string, 
                                  headers is hash<string,string>,
                    toHandler (handler . (unsafely_as ~HttpClientResponse)));
                                   
getBodyNow client uri headers handler =
   getNow client uri headers 
                do resp:
                    bodyHandler resp do buffer:
                        handler {buffer, resp}
                    done
                done;

{
    putHeaders,
    headers resp =
        (ret = [:];
        forJavaMap (resp is ~HttpClientResponse)#headers() do k v:
            ret.[string k] := if defined? v then string v else "" fi;
        done;
        ret),

    trailers resp =
        (ret = [:];
        forJavaMap (resp is ~HttpClientResponse)#trailers() do k v:
            ret.[string k] := if defined? v then string v else "" fi;
        done;
        ret),

    
    create,

    request,
    getNow,
    getBodyNow,
    
    
}
    
