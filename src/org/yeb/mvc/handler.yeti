/*
 * Copyright 2011 Christian Essl
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 */

module org.yeb.mvc.handler;


import java.util.regex:Pattern;

load org.yeb.std;
load org.yeb.mvc.webutils;
load org.yeb.validation;

typedef handlerResult = Completed string | NotHandled string | Handling string;
typedef handlerType<a> = a -> handlerResult;
typedef handlerAdapterType<a> = handlerType<a> -> handlerType<a>;
     
     
            

    
/** creates a mockRequest for testing handlers. 
 *   Use Get Post Head etc to specifiy the path. 
 *   :mockCtxt [Get "index.html"]
 *   
 *   Use Header hash<string,string>, Param hash<string,string>, to spcify param
 *   :mockCtxt [Get "index.html", Header ["accepted":"..."], Param["foo","value"]]
 *   
 *   Use Params to specify many parameter arrays
 *   :mockCtxt [Post "form", Params ["values":["1","2"]]]
 */
mockRequest opts reqPathT = 
   (var reqMethod = "GET";
    var reqPath = reqPathT is string;
    var resourcePath = "test/resources/webapp";
    var headers = [:];
    var params = [:];
    var port = 80;
    var scheme = "http";
    var body = new byte[0];
    var respondFn is responseContentType -> () = \();
    for opts do opt:case opt of
        Get ruri : (reqMethod := "GET";reqPath := ruri);
        Head ruri : (reqMethod := "HEAD";reqPath := ruri);
        Post ruri : (reqMethod := "POST";reqPath := ruri);
        Put ruri : (reqMethod := "PUT";reqPath := ruri);
        Delete ruri : (reqMethod := "DELETE";reqPath := ruri);
        Trace ruri : (reqMethod := "TRACE";reqPath := ruri);
        Connect ruri : (reqMethod := "CONNECT";reqPath := ruri);
        ResourcePath str: resourcePath := str;
        Port n : port := n;
        Scheme s : scheme := s;
        Body b: body := b;
        Header ha: 
            forHash ha do k v: headers.[k is string] := [v is string] done;
        Param ha: 
            forHash ha do k v: 
                params.[k is string] := [v is string] 
            done;
        Params ha : 
            forHash ha do k v:
                params.[k] := v;
            done;
        Response fn: respondFn := fn;
        esac;
    done;

    makeRequest port reqMethod scheme reqPath headers body respondFn; 
);


//HandlerAdapters


idHandler handler is handlerAdapterType<'a> = handler;


/**
 * Transform an url pattern to a regex. Patterns are used in routers to 
 * specify path pattern which should be handled.
 *
 * ie for the pattern:
 * :/entry/:id/:date
 * becomes the regex
 * :/entry/([^/]+)/([^/]+)/(.*)
 * and the matched parts are exposed as request-parameters
 *
 * to specify a custom regex put it between $ $ after the name of the part.
 * ie to specify that id should only contain digits:
 * :/entry/:id$d+$
 */
urlPatternToRegex pat = 
   (//:a-z is name
    //:a-z? is optional
    //* at end means rest
    //$marks start regex $ marks end regex
    
    import java.util.regex.Pattern;
    
    paS = if strEnds? pat "/*" then 
                    strLeft pat (strLength pat - 2)
               else
                    pat;
               fi;
               
    tokens = matchAll '(/?\.?):(\w+)(\$([^\$]+)\$)?(\?)?' (Token . tail) Text paS;
    
    names = tokens 
        |> map do t:
            case t of
            Token [leading, name, foo, regex, mark]: Some name;
            _ : none;
            esac
        done
        |> catSome
        |> array;
    
    reg = tokens
    |> map do x:
        case x of
        Token [leading, name, foo, regex, mark]:
           (reg = if defined? regex and (strLength regex > 0) then 
                    regex;
                  else
                    '[^/\.]+'
                  fi;
            reg2 = "(?<\(name)>\(reg))";
            
            if defined? mark then
                if defined? leading then
                    "(?:\(Pattern#quote(leading))" ^ reg2 ^ ")?" ;
                else
                    reg2 ^ "?";
                fi;
            else
                if defined? leading then
                    Pattern#quote(leading) ^ reg2
                else
                    reg2;
                fi;
            fi);
        Text tx:
           (Pattern#quote(tx));
        _ : failWith "should not happen";
        esac
    done
    |> strJoin "";
    
    regex = if strEnds? pat "/*" then
        push names "rest";
        reg ^ '(?:/(?<rest>.*))?'
    else
        reg
    fi;
    
    {
        names = nub names,
        regex
    }
    );

    

regexHandlerImpl method regexPattern handler = 
   (meth = strUpper method;
    
    {names, regex} = urlPatternToRegex regexPattern;
    pattern = Pattern#compile(regex);

    do oreq:
        if meth != "ALL" and (meth != (strUpper oreq.method)) then
            notHandled
        else
            matcher = pattern#matcher(oreq.path);
            if matcher#matches() then
                params = copy oreq.params;    

                //add the paramters
                urlParams = array [];
                for [0..matcher#groupCount()] do c:
                    push urlParams matcher#group(c);
                done;
                params.["urlParams"] := list urlParams;
                
                //add the named parameters
                for names do name:
                    _ = putListHash name (string matcher#group(name)) params;
                done;

                //set the new pathInfo and servletPath
                {path,matchedPath} = 
                    if (contains? "rest" names) 
                      and (defined? matcher#group("rest")) then
                        rest = matcher#group("rest");
                        matched = strLeft oreq.path 
                                ((strLength oreq.path) - (strLength rest)); 
                        {
                            matchedPath = oreq.matchedPath ^ matched,
                            path = rest
                        }
                    else
                        {
                            matchedPath = oreq.matchedPath ^ oreq.path,
                            path = ""
                        }
                    fi;
                handler( oreq with {path,matchedPath,params});
            else
                notHandled
            fi;
        fi;
    done;
);

/**
 * Handleradapter which takes a request method and path pattern and executes on match
 * the given handler. Normally this is not used directly but a router is used.
 * The path pattern is the same as described in urlPatternToRegex.
 *
 * to handle the Get request for index:
 * :regexHandler (Get "index") do ctxt: ....; Completed "" done;
 */
regexHandler requestUrl handler = 
   ({fst = meth , snd = regexPattern} = 
        case requestUrl of
        Get us: pair "GET" us;
        Post us: pair "POST" us;
        Put us: pair "PUT" us;
        Delete us: pair "DELETE" us;
        Options us: pair "OPTIONS" us;
        Head us: pair "HEAD" us;
        All us: pair "ALL" us;
        esac;
    regexHandlerImpl meth regexPattern handler);
    
runHandlers handlers ctxt is list<handlerType<'a>> -> 'a -> handlerResult =
    if empty? handlers then
        notHandled
    else
        case (head handlers) ctxt of
            NotHandled x :
                runHandlers (tail handlers) ctxt;
            x : x;
        esac;
    fi;

lazyHandler moduleName  is string -> handlerType<'b> =
   (import java.lang.Thread;
   
    var myHandler is (Some handlerType<'b> | None () ) = none;
    loadHandler () = (
        cl = Thread#currentThread()#getContextClassLoader()#loadClass(moduleName);
        mod = cl#getMethod(
            "eval",() as ~Class[])#invoke(() as ~Object, () as ~Object[]);
        jmod = mod unsafely_as {handler is handlerType<'b>};
        h = jmod.handler;
        myHandler := Some h;
        h;
    );
    if not ((load org.yeb.mvc.config).webDynamicReload?) then
        loadHandler();
    else
        do ctxt:
            ha = case myHandler of
                Some h: h;
                None _ : loadHandler ();
            esac;
            ha ctxt;
        done;
    fi);

handlersFact oldVhs adapter= 
   (vhs = array [];
    {
		get adapter () = adapter,
        add handler =
            push vhs (adapter handler),
        
        pattern regex handler = add ((regexHandler regex) handler),
        _get regex handler = add ((regexHandler (Get regex)) handler),
        post regex handler = add ((regexHandler (Post regex)) handler),
        put regex handler = add ((regexHandler (Put regex)) handler),
        delete regex handler = add ((regexHandler (Delete regex)) handler),        
        options regex handler = add ((regexHandler (Options regex)) handler),
        head regex handler = add ((regexHandler (Head regex)) handler),
        
        all regex handler = add ((regexHandler (All regex)) handler),        

        lazy regex moduleName = 
            add $ (regexHandler (All regex)) (lazyHandler moduleName),

        get handler () =
            runHandlers (vhs ++ oldVhs),

        newSubRouter adapter =
            handlersFact (vhs ++ oldVhs) adapter,
    });
    
/**
 * Creates a router. A router is used to handle different requests.
 *
 * ie to specify differen request handlings do:
 * :router = newRouter id;
 * :router.get "index" do ctxt: //handle get request done
 * :router.post "someform" do ctxt: //handle post request done
 * :router.add customHandler; //use to add a handler which is always executed
 * :
 * :handler = router.handler; //cunstructs an handler for all the routes
 *
 * The router will than try to match any route in the order given and execute
 * the handlerfunction if it fits.
 *
 * Each handler function must return either 
 * - Completed if the request was handled by this handler and the async Request
 *   context can be closed 
 * - NotHandled "" if the reuqest is not handled by this handler and the next 
 *   routes/handlers should be tried to match
 * - Handling "" means that the right handler was found but the async RequestContext
 *   is kept open for further processing by the handler
 *
 * The router creates itself a handler with .handler. This handler can be used
 * directly in yebWebMain.handler or can be given to another router (with .add)
 * 
 * The adapter parameter is a function whith transforms each given handler to 
 * another handler. This adapter can be used to filter each request 
 *
 * ie to make sure each request is of a certain locale and has a logged in user:
 * 
 * :router = newRouter do handler ctxt:
 *       userId = (session ctxt)#getAttribute("userid")
 *       if defined? userId then
 *          handler (ctxt with {user = loadUserFromDb userId})
 *       else
 *          redirectView "login" ctxt
 *       fi
 *    done;
 * :router.get "members"
 */
 
newRouter adapter = handlersFact [] adapter;




(load org.yeb.mvc.webutils) with {


    mockRequest,

    urlPatternToRegex,

    regexHandler,
    newRouter,
    //localeHandler,
}

