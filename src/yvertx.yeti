/*
 * Copyright 2011 Christian Essl
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 */

module yvertx;

import java.lang:Exception,
                 Runnable,
                 Long;
import java.util:Map;

import org.vertx.java.core:Handler,
                           AsyncResult,
                           AsyncResultHandler,
                           Vertx;
import org.vertx.java.core.impl:Context;
import org.vertx.java.core.buffer:Buffer;
import org.vertx.java.core.eventbus:Message;
import org.vertx.java.core.file:FileSystem,
                                FileSystemProps,
                                FileProps,
                                AsyncFile;
import org.vertx.java.core.http:HttpClientRequest,
                                HttpClientResponse,
                                HttpClient,
                                HttpServer,
                                HttpServerRequest,
                                HttpServerResponse,
                                WebSocket,
                                ServerWebSocket;
import org.vertx.java.core.json:JsonObject,
                                JsonArray;
import org.vertx.java.core.net:NetClient,
                               NetServer,
                               NetSocket;
import org.vertx.java.core.parsetools:RecordParser;
import org.vertx.java.core.sockjs:SockJSSocket,
                                  SockJSServer;
import org.vertx.java.core.streams:Pump,
                                   ReadStream,
                                   WriteStream;
import org.vertx.java.deploy:Verticle,
                             Container;
import org.vertx.java.deploy.impl:VertxLocator;



//callback functions
typedef either<a> = Exception string | Some a; 
typedef callback<a> = a -> ();
typedef asyncFunction<a> = callback<a> -> ();
typedef eitherAsyncFunction<a> = asyncFunction<either<a>>;

cbId v is 'a -> asyncFunction<'a> = do cb: cb v done;

cbeId v is 'a -> asyncFunction<either<'a>> = 
    do cb: cb (Some v) done;

cbBind fn cbfn 
    is ('a -> asyncFunction<'b>) -> asyncFunction<'a> -> asyncFunction<'b>= 
    do cb:
        cbfn do a: (fn a) cb done
    done;

cbeBind fn cbfn
    is ('a -> eitherAsyncFunction<'b>) -> eihterAsyncFunction<'a> 
        -> eitherAsyncFunction<'b> =
    do cb:
        cbfn \case of
            Exception str: cb (Exception str);
            Some a: (fn a) cb;
            esac;
    done;
    

cbFlatten cbfn is asyncFunction<asyncFunction<'a>> -> asyncFunction<'a> = 
    cbBind id cbfn;

cbeFlatten cbfn 
    is eitherAsyncFunction<eitherAsyncFunction<'a>> -> eitherAsyncFunction<'a> =
    cbeBind id cbfn;

cbMap fn cbfn is ('a -> 'b) -> asyncFunction<'a> -> asyncFunction<'b>=
    do cb:
        cbfn do a: cb (fn a) done
    done;

cbeMap fn cbfn is ('a -> 'b) -> eitherAsyncFunction<'a> 
                -> eitherAsyncFunction<'b> =
    do cb:
        cbfn \case of
            Exception str: cb (Exception str);
            Some a: cb (fn a)
            esac
    done


cbLift fn a cb is ('a -> 'b) -> ('a -> asyncFunction<'b>)=
    cb (fn a);

cbeLift fn a cb is ('a -> 'b) -> ('a -> eitherAsyncFunction<'b>) =
    cb (fn (Some a))
    
cbSeq cbfns cb is list?<asyncFunction<'a>> -> callback<list<'a>> -> ()=
    (res = array [];
     for cbfns do c:
        c do a:
            push res a;
            if length res == length cbfns then
                cb (list res);
            fi
        done;
    done);
cbeSeq cbfns cb 
    is list?<eitherasyncFunctiona<'a>> -> callback<either<list<'a>>> -> () =
    (res = array [];
    var handled = false;
    for cbfns do c:
        c \case of
            Exception str: 
                if not handled then
                    handled := true;
                    cb (Exception str);
                fi;
            Some a:
                if not handled then
                    push res a;
                    if length res == length cbfns then
                        handled := true;
                        cb (list res);
                    fi
                fi
            esac;
    done);


cbStruTH = threadLocal none;

cbSet cbfn is asyncFunction<'a> -> (() -> 'a) =
    (ctr = case cbStruTH.value of
        None _ : failWith "cbSet must only be used directly in cbCol";
        Some r: r;
        esac;
    ctr.starting();
    var hasReceived = false;
    var res = NotSet ();
    cbfn do a:
        res := Some a;
        if not hasReceived then
            ctr.hasReceived (Some ());
            hasReceived := true
        fi;
    done;
    \(case res of
        NotSet (): failWith "Not set";
        Some v: v
      esac));    


cbeSet cbfn is eitherAsyncFunction<'a> -> (() -> 'a) =
    (ctr = case cbStruTH.value of
        None _ : failWith "cbSet must only be used directly in cbCol";
        Some r: r;
        esac;
    ctr.starting();
    var hasReceived = false;
    var res = NotSet ();
    cbfn \case of
        Exception str: 
            if not hasReceived then
                res := Exception str;
                ctr.hasReceived (Exception str);
                hasReveived := true;
            fi;
        Some a:
            res := Some a;
            if not hasReceived then
                ctr.hasReceived (Some ());
                hasReceived := true
            fi;
    esac;
    \(case res of
        NotSet (): failWith "Not set";
        Exception str: failWith str;
        Some v: v
      esac));    


cbeCol inex cb is (() -> 'a) -> eihterAsyncFunction<'a>=
    (var called = false;
     var requests = 0;
     var received = 0;
     var result = none;
     ctr = {
        starting () = 
            requests := requests + 1,
        hasReceived ex =
            case ex of
            Exception str :
                called := true;
                cb (Exception str);
            Some _ :
                received := received + 1;
                if not called then
                    case result of
                    None _ : ();
                    Some v: 
                        if received == requests then
                            called := true;
                            cb v;
                        fi;
                    esac;
                fi;
            esac,
    };
    oCtr = cbStruTH.value;
    try 
        cbStruTH.value := Some ctr;
        r = inex (); 
        result := Some r;
        if not called and received == requests then
            called := true;
            cb r
        fi;
            
    catch Exception ex:
        if not called then
            called := true;
            cb (Exception (string ex));
        fi
    finally
        cbStruTH.value := oCtr;
    yrt;
    ());

cbRun exfn = exfn \();

noex fn = do cb:
    case cb of
    Exception ex: throw (ex is ~Exception);
    Some v: (fn is 'a -> ()) v;
    esac;
done;


emptyJS = {´_´ = ()};

_toJS object = 
   (import yeti.lang:Num, FloatNum, RatNum,AList, ByKey, Struct, Tag;
    import java.util:ArrayList,Map, HashMap;
   
    o = object as ~Object;
    if nullptr? o then
        o
    elif same? o (emptyJS as ~Object) then
        new JsonObject() 
    elif (o instanceof FloatNum) 
         or (o instanceof RatNum) then
        (o unsafely_as ~Num)#toBigDecimal();
    elif (o instanceof Num) then
        (o unsafely_as ~Num)#toBigInteger();
    elif o instanceof AList then
        jl = new JsonArray();
        for (o unsafely_as list<'a>) do v:
            _ = jl#add(_toJS v);
        done;
        jl as ~Object;
    elif o instanceof ByKey then
        dbo = new HashMap();
        i = (o unsafely_as ~Map)#entrySet()#iterator();
        i#hasNext() loop
            (e = i#next() unsafely_as ~java.util.Map$Entry;
             key = string (e#getKey());
             _ = dbo#put(key, _toJS (e#getValue() unsafely_as 'a)));
        new JsonObject(dbo);
    elif o instanceof Struct then
        st = o unsafely_as ~Struct;
        dbo = new HashMap();
        for [0 .. st#count() - 1] do i:
            name = st#name(i);
            value = _toJS (st#get(i) unsafely_as 'a);
            _ = dbo#put(name, value);
        done;
        new JsonObject(dbo);
    elif o instanceof Tag then
        t = o unsafely_as ~Tag;
        if t#name == "Some" then
            _toJS (t#value unsafely_as 'a);
        elif t#name == "None" then
            () as ~Object;
        else
            failWith "Can not serialize \(o)"
        fi
    else
        o
    fi);
    
toJS stru is 'a -> ~JsonObject =
    _toJS stru unsafely_as ~JsonObject;

toJSArray ls is list<'a> -> ~JsonArray =
   (ar = new JsonArray();
    for ls do e:
        _ = ar#add(toJS e)
    done;
    ar);
    
_fromJS object = 
   (import java.util:List,HashMap,Map;
    import java.lang:Number;
    import yvertx:HashStruct;
    
    o = object as ~Object;
    
    if nullptr? o then
         o;
    elif o instanceof Number then
       (import java.lang: Double, Float,Number;
        import java.math: BigInteger, BigDecimal;
        import yeti.lang:Num,BigNum,IntNum,FloatNum;
        if (o instanceof Double) or
             (o instanceof Float) or
             (o instanceof BigDecimal)
             then
                nu = o unsafely_as ~Number;
                new FloatNum(nu#doubleValue());
        elif o instanceof BigInteger then
            nu = o unsafely_as ~BigInteger;
            new BigNum(nu);
        elif o instanceof Num then
            o unsafely_as ~Num;
        else
            nu = o unsafely_as ~Number;
            new IntNum(nu#longValue());
        fi)
    elif o instanceof JsonArray then
        it = (o unsafely_as ~JsonArray)#iterator();
        ar = array [];
        (it#hasNext()) loop push ar (_fromJS it#next());
        (list ar) as ~Object;
    elif o instanceof JsonObject then
        ma = new HashMap();
        i = (o unsafely_as ~JsonObject)#toMap()#entrySet()#iterator();
        i#hasNext() loop
           (e = i#next() unsafely_as ~java.util.Map$Entry;
            value = _fromJS (e#getValue() unsafely_as 'a);
            if not nullptr? value then
                ma#put(string e#getKey(), value);
            fi);
        if ma#size() == 0 then
            emptyJS as ~Object;
        else
            new HashStruct(ma);
        fi
    else
        o
    fi);

    
fromJS object is ~JsonObject -> 'a =
    (_fromJS object) unsafely_as 'a;

fromJSArray ar is ~JsonArray -> list<'a> =
    (_fromJS ar) unsafely_as list<'a>;    

blend v1 v2 is 'a -> 'b -> 'a =
    (import yeti.lang:Struct,
                      GenericStruct;
    import java.util.HashMap;

    o1 = v1 unsafely_as ~Object;
    o2 = v2 unsafely_as ~Object;
    if defined? v1 and defined? v2 and 
       o1 instanceof ~Struct and o2 instanceof ~Struct then

        s1 = o1 unsafely_as ~Struct;
        s2 = o2 unsafely_as ~Struct;
        jmap = new HashMap();
        for [0..(s1#count - 1)] do i:
            na = s1#name(i);
            va = s1#get(i);
            _ = jmap#put(na,va);
        done;
        for [0..(s2#count - 1)] do i:
            na = s1#name(i);
            va = s1#get(i);
            ov = jmap#get(na);
            va2 = if defined? ov then
                    blend ov va
                  else 
                      va;
                  fi;
            _ = jmap#put(na,va2);
        done;
        (new GenericStruct(jmap)) unsafely_as 'a;
    else
        v1
    fi);

hostAndPort hostPort =
   (i = strIndexOf hostPort ":" 0;
    if i < 0 then 
        {port = 80, host = hostPort}
    elif i == 0 then
        {hostPort = "localhost", port = int (number (strRight hostPort 1))}
    else
       {host = strLeft hostPort i,
        port = int (number (strRight hostPort (i+1)))}
    fi);


toHandler fn is (~Object -> ()) -> ~Handler = 
   (class IYetiHandler extends Handler
        void handle(Object ob)
            fn ob,
    end;
    new IYetiHandler());

toSimpleHandler fn =
    toHandler (fn . \());

toLongHandler fn =
    toHandler do ob: fn (ob unsafely_as ~Long)#longValue() done;
        


toAsyncResultHandler fn =
       (class IYetiAsyncResultHandler extends AsyncResultHandler
            void handle(Object o)
                r = o unsafely_as ~AsyncResult;
                if (r is ~AsyncResult)#succeeded() then
                    fn (Some r#result)
                else
                    fn (Exception r#exception);
                fi,
        end;
        new IYetiAsyncResultHandler());

toTypedAsyncResultHandler tfn fn 
    is (~Object -> 'a) -> ((Some 'a | Exception ~Exception ) -> 'b) 
        -> ~AsyncResultHandler =
       (class IYetiAsyncResultHandler extends AsyncResultHandler
            void handle(Object o)
                r = o unsafely_as ~AsyncResult;
                if (r is ~AsyncResult)#succeeded() then
                   fn (Some (tfn r#result))
                else
                   fn (Exception r#exception);
                fi,
        end;
        new IYetiAsyncResultHandler());
        
toBufferHandler fn =
        toHandler (fn . (unsafely_as ~Buffer));

    
toExceptionHandler fn =
        toHandler (fn . (unsafely_as ~Exception));
        
toStringHandler fn =
        toHandler (fn . (as string) .(unsafely_as ~String));

dataHandler rs handler =
    (rs is ~ReadStream)#dataHandler(toBufferHandler handler);

endHandler rs handler =
    (rs is ~ReadStream)#endHandler(toSimpleHandler handler);

exceptionHandler rs handler =
    (rs is ~ReadStream)#exceptionHandler(toExceptionHandler handler);

drainHandler ws handler =
    (ws is ~WriteStream)#drainHandler(toSimpleHandler handler);

wsExceptionHandler ws handler =
    (ws is ~WriteStream)#exceptionHandler(toExceptionHandler handler);

vertxThreadLocal = threadLocal VertxLocator#vertx;

containerThreadLocal = threadLocal VertxLocator#container;

getVertx () = 
    (loc = vertxThreadLocal.value;
    if not defined? loc then
        VertxLocator#vertx;
    else
        loc
    fi);

getContainer () =
    (loc = containerThreadLocal.value;
    if not defined? loc then
        VertxLocator#container;
    else
        loc;
    fi);

runOnLoop handler = 
    (getVertx ())#runOnLoop(toSimpleHandler handler);

setPeriodic  delay handler = 
    (getVertx ())#setPeriodic(delay, 
        toLongHandler handler);

setTimer delay handler =
    (getVertx ())#setTimer(delay, 
        toLongHandler handler);

cancelTimer timerId =
    (getVertx ())#cancelTimer(timerId);
    
verticle runFn 
        is ({vertx is ~Vertx, container is ~Container} 
            -> ({vertx is ~Vertx, container is ~Container} -> 'a)) 
            -> ( () -> ~Verticle) =
   (class IYetiVerticle extends Verticle 
        var stopFn = \(failWith "No stopfuntion assigned yet"),
        
        void start()
            stopFn := 
                runFn {vertx = this#getVertx(), container = this#getContainer()},
        void stop()
            stopFn {vertx = this#getVertx(), container = this#getContainer()},
    end;
    \(new IYetiVerticle() as ~Verticle));

 
deployModule name config instances handler = 
    (getContainer ())#deployModule(name is string, 
                                            toJS config, 
                                            instances is number, 
                                            toStringHandler handler);

deployVerticle name config instances handler= 
    (getContainer ())#deployVerticle(name is string, 
                                                toJS config, 
                                                instances is number, 
                                                toStringHandler handler);
    
config () = fromJS ((getContainer ())#getConfig());


_enviroment () = 
   (ret = [:];
    forJavaMap ((getContainer ())#getEnv()) do key value: 
        ret.[string key] := string value;
    done;
    ret);


undeployModule deploymentID handler =
    (getContainer ())#undeployModule(deploymentID, 
                                    toSimpleHandler handler);
    
undeployVerticle deploymentID handler =
    (getContainer ())#undeployVerticle(deploymentID, 
                                    toHandler handler);

timeout time tofn fn = 
    (var handled = false;

    _ = setTimer time do:
        if not handled then
            handled := true;
            tofn time;
        fi
    done;
    
    do arg:
        if not handled then
            handled := true;
            fn Some;
        fi
    done);
//http server things
httpServerRequestHandler server handler =
   (server is ~HttpServer)#requestHandler(
        toHandler (handler . (unsafely_as ~HttpServerRequest)));
        

createHttpServer () = 
    (getVertx())#createHttpServer();

createHttpServerWithHandler handler = 
    (getVertx())#createHttpServer()#requestHandler(
        toHandler (handler . (unsafely_as ~HttpServerRequest)));
    
closeHttpServer server handler =
    (server is ~HttpServer)#close(toSimpleHandler handler);

newRouteMatcher () =
   (import org.vertx.java.core.http:RouteMatcher;
   _rm = new RouteMatcher();
   toHa h = toHandler (h . (unsafely_as ~HttpServerRequest));
     
    {
        all route h = _rm#all(route,toHa h), 
        allWithRegex route h = _rm#allWithRegEx(route,toHa h), 
        connect route h = _rm#connect(route,toHa h),
        connectWithRegEx route h = _rm#connectWithRegEx(route,toHa h),
        delete route h = _rm#delete(route,toHa h), 
        deleteWithRegEx route h = _rm#deleteWithRegEx(route,toHa h), 
        _get route h = _rm#get(route,toHa h),
        getWithRegEx route h = _rm#getWithRegEx(route,toHa h), 
        head route h = _rm#head(route,toHa h), 
        headWithRegEx route h = _rm#headWithRegEx(route,toHa h), 
        options route h = _rm#options(route,toHa h), 
        optionsWithRegEx route h = _rm#optionsWithRegEx(route,toHa h), 
        patch route h = _rm#patch(route,toHa h), 
        patchWithRegEx route h = _rm#patchWithRegEx(route,toHa h), 
        post route h = _rm#post(route,toHa h), 
        postWithRegEx route h = _rm#postWithRegEx(route,toHa h), 
        put route h = _rm#put(route,toHa h), 
        putWithRegEx route h = _rm#putWithRegEx(route,toHa h), 
        trace route h = _rm#trace(route,toHa h), 
        traceWithRegEx route h = _rm#traceWithRegEx(route,toHa h), 
        noMatch h = _rm#noMatch(toHa h),
        rm = _rm,
        handle req = _rm#handle(req is ~HttpServerRequest),
        createServer () = 
            (getVertx())#createHttpServer()#requestHandler(_rm),

        route fullpattern handler =
            ({regex,methodPattern} =
                if strStarts? fullpattern "regex:" then
                    {regex = true, 
                    methodPattern = strRight fullpattern 6}
                else
                    {regex = false,
                     methodPattern = fullpattern}
                fi;
            {method, pattern} =
                (cut = strIndexOf methodPattern ":" 0;
                if cut < 0 then
                    {method = "", pattern = methodPattern}
                else
                    {method = strUpper(strLeft methodPattern cut),
                    pattern = strRight methodPattern (cut + 1)}
                fi);
            h = toHa handler;
            if regex then
                case method of
                "ALL" : _rm#allWithRegEx(pattern,h);
                "CONNECT" : _rm#connectWithRegEx(pattern,h);
                "DELETE" : _rm#deleteWithRegEx(pattern,h);
                "GET" : _rm#getWithRegEx(pattern,h);
                "HEAD" : _rm#headWithRegEx(pattern,h);
                "OPTIONS": _rm#optionsWithRegEx(pattern,h);
                "PATCH" : _rm#patchWithRegEx(pattern,h);
                "POST" : _rm#postWithRegEx(pattern,h);
                "PUT" : _rm#putWithRegEx(pattern,h);
                "TRACE" : _rm#traceWithRegEx(pattern,h);
                _ : _rm#allWithRegex(fullpattern, h);
                esac;
            else
                case method of
                "ALL" : _rm#all(pattern,h);
                "CONNECT" : _rm#connect(pattern,h);
                "DELETE" : _rm#delete(pattern,h);
                "GET" : _rm#get(pattern,h);
                "HEAD" : _rm#head(pattern,h);
                "OPTIONS": _rm#options(pattern,h);
                "PATCH" : _rm#patch(pattern,h);
                "POST" : _rm#post(pattern,h);
                "PUT" : _rm#put(pattern,h);
                "TRACE" : _rm#trace(pattern,h);
                _ : _rm#all(fullpattern, h);
                esac;

            fi)
    });        
        
 
putResponseHeaders request headers =
   ((request is ~HttpServerRequest)#response#headers()#putAll(
        (headers is hash<string,string>) as ~Map);
    ());

putResponseTrailers request trailers =
    ((request is ~HttpServerRequest)#response#trailers()#putAll(
        (trailers is hash<string,string>) as ~Map);
    ());

params req =
   (ret = [:];
    forJavaMap (req is ~HttpServerRequest)#params() do key value:
        ret.[string key] := if defined? value then string value else "" fi;
    done;
    ret);
    
requestHeaders req =
    (ret = [:];
    forJavaMap (req is ~HttpServerRequest)#headers() do key value:
        ret.[string key] := if defined? value then string value else "" fi;
    done;
    ret);

//http client things
bodyHandler response handler =
   (import org.vertx.java.core.http.impl:HttpReadStreamBase; 
   (response is ~HttpReadStreamBase)#bodyHandler(
        toBufferHandler handler));
   
createHttpClient hostPort = 
   ({port,host} = hostAndPort hostPort; 
    (getVertx())#createHttpClient()#setPort(port)#setHost(host));

putRequestHeaders request headers =
   ((request is ~HttpClientRequest)#headers()#putAll(
        (headers is hash<string,string>) as ~Map);
    request);

responseHeaders resp =
    (ret = [:];
    forJavaMap (resp is ~HttpClientResponse)#headers() do k v:
        ret.[string k] := if defined? v then string v else "" fi;
    done;
    ret);

responseTrailers resp =
    (ret = [:];
    forJavaMap (resp is ~HttpClientResponse)#trailers() do k v:
        ret.[string k] := if defined? v then string v else "" fi;
    done;
    ret);
    
httpRequest client muri headers handler =
    (h = toHandler (handler . (unsafely_as ~HttpClientResponse));
    req = case muri of
    Connect uri: 
        (client is ~HttpClient)#connect(uri is string, h);
    Delete uri:    
        client#delete(uri is string, h);
    Get uri: 
        client#get(uri is string, h);
    Head uri:
        client#head(uri is string, h);
    Options uri:
        client#options(uri is string, h);
    Patch uri:
        client#patch(uri is string, h);
    Put uri:
        client#put(uri is string, h);
    Post uri:
        client#post(uri is string, h);
    Trace uri:
        client#trace(uri is string, h);
    Request {method, uri}:
        client#request(method is string, uri is string, h); 
    esac;
    putRequestHeaders req headers);

getHttpNow client uri headers handler =
   (client is ~HttpClient)#getNow(uri is string, 
                                  headers is hash<string,string>,
                    toHandler (handler . (unsafely_as ~HttpClientResponse)));
                                   
getHttpBodyNow client uri headers handler =
   getHttpNow client uri headers 
                do resp:
                    bodyHandler resp do buffer:
                        handler {buffer, resp}
                    done
                done;
//websocket functions
connectWebSocketServer server fn =
    ((server is ~HttpServer)#websocketHandler(
            toHandler (fn . (unsafely_as ~ServerWebSocket)));
    ());

connectWebSocketClient client uri handler =
    (client is ~HttpClient)
        #connectWebsocket(uri is string,
                          toHandler (handler .(unsafely_as ~WebSocket)));

closedWebSocket socket handler =
   (socket is ~WebSocket)#closedHandler(toSimpleHandler handler);


//sockjs functions

createSockJSServer server =
    (getVertx())#createSockJSServer(server);

installSockJSApp server config handler =
    (server is ~SockJSServer)#installApp(toJS config, 
                 toHandler (handler . (unsafely_as ~SockJSSocket)));  

bridgeSockJS server opts sjsConfig inboundPermitted outboundPermitted =
   (var authTimeout = 5 * 60 * 1000;
    var authAddress = "vertx.basicauthmanager.athorise";
    for opts do opt:
        case opt of
        AuthTimeout n : authTimeout := n;
        AuthAddress a : authAddress := a;
        esac
    done;
    (server is ~SockJSServer)#bridge(toJS sjsConfig, 
             toJSArray inboundPermitted, 
             toJSArray outboundPermitted,
             authTimeout,
             authAddress));


//net functions
netsocketClosed socket handler =
    (socket is ~NetSocket)#closedHandler(toSimpleHandler handler);
    
createNetClient () = 
    (getVertx())#createNetClient();

connectNetClient client hostPort exceptionHandler handler =
    ({host,port} = hostAndPort hostPort;
     (client is ~NetClient)#exceptionHandler(
            toExceptionHandler exceptionHandler);
     _ = client#connect(port is number, host is string,
                toHandler (handler . (unsafely_as ~NetSocket)));
     ());

createAndConnectNetClient hostPort settings exceptionHandler handler=
    (client = createNetClient ();
    _ = settings client;
    connectNetClient client hostPort exceptionHandler handler;
    client);
    
createNetServer () =
    (getVertx())#createNetServer();

connectNetServer server handler =
    (server is ~NetServer)#connectHandler(
        toHandler (handler . (unsafely_as ~NetSocket)));

createAndConnectNetServer handler =
    connectNetServer(createNetServer ()) handler;

closeNetServer server handler =
    (server is ~NetServer)#close(toSimpleHandler handler);

closeNetClient client =
    (client is ~NetClient)#close();


//bus things
toEitherJsonMessageHandler fn =
    (class YvertxEitherMessageHandler extends Handler
        void handle(Object ob)
            msg = ob unsafely_as ~Message;
            body = fromJS (msg#body unsafely_as ~JsonObject);
            if defined? body.status and body.status == "error" then
                emg = if defined? body.message then
                          string body.message
                      else 
                          "error but no message" 
                      fi;
                fn (Exception msg);
            else
                fn  
                    {message = msg,
                    handler = this as ~Handler,
                    get body () = 
                        fromJS (msg#body unsafely_as ~JsonObject),
                    get replyAddress () = string msg#replyAddress,
                    reply v = msg#reply(toJS v),
                    request v handler = 
                        msg#reply(toJS v, toEitherJsonMessageHandler handler)
                   };
            fi,

    end;
    new YvertxEitherMessageHandler() as ~Handler);
toJsonMessageHandler fn =
    (class YvertxMessageHandler extends Handler
        void handle(Object ob)
            msg = ob unsafely_as ~Message;
            body = fromJS (msg#body unsafely_as ~JsonObject);
            fn  
                {message = msg,
                handler = this as ~Handler,
                get body () = 
                    fromJS (msg#body unsafely_as ~JsonObject),
                get replyAddress () = string msg#replyAddress,
                reply v = msg#reply(toJS v),
                request v handler = 
                    msg#reply(toJS v, toEitherJsonMessageHandler handler)
               },

    end;
    new YvertxMessageHandler() as ~Handler);

publish address msg = 
    (getVertx ())#eventBus()#publish(address is string, toJS msg);

send address msg =
    (getVertx ())#eventBus()#send(address is string, toJS msg);

sendWithHandler address msg handler =
    (getVertx ())#eventBus()#send(address is string, toJS msg, 
            toJsonMessageHandler handler);

request address msg handler =   
    (getVertx ())#eventBus()#send(address is string, toJS msg, 
            toEitherJsonMessageHandler handler);

requestBody address msg handler =
    (cbeMap (.body) (request address msg)) handler;
    
registerBusHandler address resultHandler handler =
    (getVertx ())#eventBus()#registerHandler(address is string,
                            toJsonMessageHandler handler,
                            toAsyncResultHandler resultHandler);
    
registerLocalBusHandler address handler =
    (getVertx ())#eventBus()#registerLocalHandler(address is string,
                   toJsonMessageHandler handler);
        

unregisterBusHandler id handler resultHandler =
    (getVertx ())#eventBus()#unregisterHandler(id is string, handler, 
                          toAsyncResultHandler resultHandler);

//filesystem
fsHelper = {
    closeAFile file handler =
        (file is ~AsyncFile)#close(toAsyncResultHandler handler),

    flushAFile file handler =
        (file is ~AsyncFile)#flush(toAsyncResultHandler handler),

    readAFile file buffer offset position length handler =
        (file is ~AsyncFile)#read(buffer is ~Buffer, offset is number,
                                  position is number,
                                  length is number,
                                  toTypedAsyncResultHandler 
                                    (unsafely_as ~Buffer) handler),

    writeAFile file buffer position handler =
        (file is ~AsyncFile)#write(buffer is ~Buffer, position is number,
                                   toAsyncResultHandler handler),
};

fileSystem = ({
    get fs () = ((getVertx ())#fileSystem()),
    chmod path perms handler =
        ((getVertx())#fileSystem())#chmod(path is string, perms is string, 
                    toAsyncResultHandler handler),

    chmodDir path perms dirPerms handler =
        ((getVertx ())#fileSystem())#chmod(path is string, 
                         perms is string, dirPerms is string,
                         toAsyncResultHandler handler),

    copy from to recursive handler =
        ((getVertx ())#fileSystem())#copy(from is string, to is string, 
                         recursive is boolean, toAsyncResultHandler handler),

    createFile path perms handler =
        case perms of
        None _ :
            ((getVertx ())#fileSystem())#createFile(path is string, 
                                            toAsyncResultHandler handler);
        Some perm:
            ((getVertx ())#fileSystem())#createFile(path, perm is string, 
                        toAsyncResultHandler handler);
        esac,

    delete path recursive handler =
        ((getVertx ())#fileSystem())#delete(path is string, 
                    recursive is boolean, 
                    toAsyncResultHandler handler),

    exists path handler =
        ((getVertx ())#fileSystem())#exists(path is string, 
                toTypedAsyncResultHandler (unsafely_as boolean) handler),
        
    fsProps path handler =
        ((getVertx ())#fileSystem())#fsProps(path is string, 
                     toTypedAsyncResultHandler 
                        (unsafely_as ~FileSystemProps) handler),

    link link existing handler =
        ((getVertx ())#fileSystem())#link(link is string, existing is string, 
                    toAsyncResultHandler handler),
     
    lprops path handler =
        ((getVertx ())#fileSystem())#lprops(path is string, 
                    toTypedAsyncResultHandler 
                        (unsafely_as ~FileProps) handler),

    mkdir path perms createParents handler =
        case perms of
        None () : 
            ((getVertx ())#fileSystem())#mkdir(path is string, 
                       createParents is boolean, toAsyncResultHandler handler);
        Some perm:
            ((getVertx ())#fileSystem())#mkdir(path is string, perm is string, 
                       createParents is boolean, toAsyncResultHandler handler);
        esac,

    move from to handler =
        ((getVertx ())#fileSystem())#move(from is string, to is string, 
                                          toAsyncResultHandler handler),

    props path handler =
        ((getVertx ())#fileSystem())#props(path is string, 
                   toTypedAsyncResultHandler (unsafely_as ~FileProps) handler),
        
    readDir path filter handler =
       (mfn obj = map string (wrapArray ((obj is ~Object) 
                                    unsafely_as ~String[]));
        case filter of
        None ():
            ((getVertx ())#fileSystem())#readDir(path is string, 
                         toTypedAsyncResultHandler mfn handler);
        Some fil:
            ((getVertx ())#fileSystem())#readDir(path is string, 
                         fil is string, toTypedAsyncResultHandler mfn handler);
        esac),

    readFile path handler =
        ((getVertx ())#fileSystem())#readFile(path is string, 
                      toTypedAsyncResultHandler (unsafely_as ~Buffer) handler),

    readSymlink path handler =
        ((getVertx ())#fileSystem())#readSymlink(path is string, 
                         toTypedAsyncResultHandler 
                            (unsafely_as string) handler),
        
    symlink link existing handler =
        ((getVertx ())#fileSystem())#symlink(link is string, 
                     existing is string, 
                     toAsyncResultHandler handler),

    truncate path len handler =
        ((getVertx ())#fileSystem())#truncate(path is string, 
                      len is number, toAsyncResultHandler handler),

    unlink link handler =
        ((getVertx ())#fileSystem())#unlink(link is string, 
                                            toAsyncResultHandler handler),

    writeFile path data handler =
        ((getVertx ())#fileSystem())#writeFile(path is string, 
                       data is ~Buffer, 
                       toAsyncResultHandler handler),

    open opts path handler =
       (var createNew = true;
        var flush = false;
        var read = true;
        var write = true;
        var perms = () as ~String;
        for opts do opt:
            case opt of
            CreateNew b : createNew := b;
            Read b: read := b;
            Write b: write := b;
            Flush b: flush := b;
            Perms s: perms := s;
            esac
        done;
        
        ((getVertx ())#fileSystem())#open(path is string, perms, read, 
                  write, createNew, flush, 
                  toTypedAsyncResultHandler 
                        (unsafely_as ~AsyncFile) handler)),

    } with fsHelper);


 
{
    //callback functions
    cbId,
    cbBind,
    cbFlatten,
    cbMap,
    cbLift,
    cbSeq,
    cbSet,
    cbCol,
    (->) cbfn fn =  cbMap fn cbfn,
    (->>) cbfn fn = cbBind fn cbfn,
    ($) a b = a b,
    noex,

    get context () =  Context#getContext(),
    addCloseHook key fn = 
        Context#getContext()#putCloseHook(key is string, runnable fn),
    executeOnWorker fn = 
        Context#getContext()#executeOnWorker(runnable fn),
    

    toHandler, 
    toSimpleHandler,
    toAsyncResultHandler, 
    toExceptionHandler,
    toBufferHandler,
    
    toJS, 
    toJSArray,
    fromJS, 
    fromJSArray,
    emptyJS, 

    dataHandler,
    endHandler,
    exceptionHandler,
    drainHandler,
    wsExceptionHandler,
    
    verticle,
    newBuffer size = new Buffer(size is number),
    newStringBuffer str = new Buffer(str is string),
    newEncodedBuffer str encoding = 
        new Buffer(str is string, encoding is string),
    newByteBuffer bytes =
        new Buffer(bytes is ~byte[]),
    
    createPump readStream writeStream = 
        Pump#createPump(readStream, writeStream), 

    runOnLoop, 
    setPeriodic, 
    setTimer, 
    get logger () = (getContainer ())#getLogger(),
    
    get sharedData ()= 
        (getVertx ())#sharedData(),
    
    

    deployModule, 
    deployVerticle, 
    config, 
    get enviroment () = _enviroment (),
    undeployModule, 
    undeployVerticle,

    helper = {
        hostAndPort,
        toTypedAsyncResultHandler
    } with fsHelper,
    
    //http server functions
    bodyHandler,
    httpServerRequestHandler,
    createHttpServer,
    createHttpServerWithHandler,
    closeHttpServer,
    newRouteMatcher,
    putResponseHeaders,
    putResponseTrailers,
    params,
    requestHeaders,

    //http client functions
    createHttpClient,
    putRequestHeaders,
    responseHeaders,
    responseTrailers,
    httpRequest,
    getHttpNow,
    getHttpBodyNow,

    //websocket
    connectWebSocketServer,
    connectWebSocketClient,
    closedWebSocket,

    //sockjs
    installSockJSApp,
    bridgeSockJS,
    createSockJSServer,

    //net functions
    netsocketClosed,
    createNetClient,
    connectNetClient,
    createAndConnectNetClient,
    connectNetServer,
    createNetServer,
    createAndConnectNetServer,
    closeNetServer,
    closeNetClient,

    //bus functions
    publish,
    send,
    request,
    requestBody,
    registerBusHandler,
    registerLocalBusHandler,
    unregisterBusHandler,

    //filesystem
    fileSystem,

    obj x = x unsafely_as ~Object,

    timeout,
    cancelTimer,

    getContainer,
    getVertx,
    get container () = getContainer(),
    get vertx () = getVertx(),
    withVertx vertx fn =
        (ov = vertxThreadLocal.value;
        vertxThreadLocal.value := (vertx is ~Vertx);
        try
            fn ();
        finally
            vertxThreadLocal.value := ov;
        yrt),
    vertxThreadLocal,
    containerThreadLocal,

    maybeDefined wrongFn rightFn value =
        if defined? value then rightFn value else wrongFn () fi,

    onDefined fn v = if defined? v then Some (fn v) else none fi,
    isString x = x ^ "",
    isNumber x = x + 0,
    isBoolean x = if x then x else x fi,

    //recordparser
    fixedRecordParser size handler = 
       (parser = RecordParser#newFixed(size is number, 
                                       toBufferHandler handler);
        do buffer: parser#handle(buffer is ~Buffer) done),
        
    delimitedRecordParser delimiter handler = 
       (parser = RecordParser#newDelimited(delimiter is string, 
                                       toBufferHandler handler);
        do buffer: parser#handle(buffer is ~Buffer) done),    
    
}
