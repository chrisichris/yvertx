/*
 * Copyright 2011 Christian Essl
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 */

module yvertx;

import java.lang:Exception,
                 Runnable;

import org.vertx.java.core:Handler,
                           AsyncResult,
                           AsyncResultHandler,
                           Vertx;
import org.vertx.java.core.buffer:Buffer;
import org.vertx.java.core.streams:Pump;                           
import org.vertx.java.core.json:JsonObject,
                           JsonArray;
import org.vertx.java.core.impl:Context;
import org.vertx.java.core.eventbus:Message;
import org.vertx.java.deploy:Verticle,
                             Container;


import org.vertx.java.core.file:FileSystem,
                                FileSystemProps,
                                FileProps,
                                AsyncFile;

emptyJS = {´_´ = ()};

_toJS object = 
   (import yeti.lang:Num, FloatNum, RatNum,AList, ByKey, Struct, Tag;
    import java.util:ArrayList,Map, HashMap;
   
    o = object as ~Object;
    if nullptr? o then
        o
    elif same? o (emptyJS as ~Object) then
        new JsonObject() 
    elif (o instanceof FloatNum) 
         or (o instanceof RatNum) then
        (o unsafely_as ~Num)#toBigDecimal();
    elif (o instanceof Num) then
        (o unsafely_as ~Num)#toBigInteger();
    elif o instanceof AList then
        jl = new JsonArray();
        for (o unsafely_as list<'a>) do v:
            _ = jl#add(_toJS v);
        done;
        jl as ~Object;
    elif o instanceof ByKey then
        dbo = new HashMap();
        i = (o unsafely_as ~Map)#entrySet()#iterator();
        i#hasNext() loop
            (e = i#next() unsafely_as ~java.util.Map$Entry;
             key = string (e#getKey());
             _ = dbo#put(key, _toJS (e#getValue() unsafely_as 'a)));
        new JsonObject(dbo);
    elif o instanceof Struct then
        st = o unsafely_as ~Struct;
        dbo = new HashMap();
        for [0 .. st#count() - 1] do i:
            name = st#name(i);
            value = _toJS (st#get(i) unsafely_as 'a);
            _ = dbo#put(name, value);
        done;
        new JsonObject(dbo);
    elif o instanceof Tag then
        t = o unsafely_as ~Tag;
        if t#name == "Some" then
            _toJS (t#value unsafely_as 'a);
        elif t#name == "None" then
            () as ~Object;
        else
            failWith "Can not serialize \(o)"
        fi
    else
        o
    fi);
    
toJS stru is 'a -> ~JsonObject =
    _toJS stru unsafely_as ~JsonObject;

toJSArray ls is list<'a> -> ~JsonArray =
   (ar = new JsonArray();
    for ls do e:
        _ = ar#add(toJS e)
    done;
    ar);
    
_fromJS object = 
   (import java.util:List,HashMap,Map;
    import java.lang:Number;
    import yvertx:HashStruct;
    
    o = object as ~Object;
    
    if nullptr? o then
         o;
    elif o instanceof Number then
       (import java.lang: Double, Float,Number;
        import java.math: BigInteger, BigDecimal;
        import yeti.lang:Num,BigNum,IntNum,FloatNum;
        if (o instanceof Double) or
             (o instanceof Float) or
             (o instanceof BigDecimal)
             then
                nu = o unsafely_as ~Number;
                new FloatNum(nu#doubleValue());
        elif o instanceof BigInteger then
            nu = o unsafely_as ~BigInteger;
            new BigNum(nu);
        elif o instanceof Num then
            o unsafely_as ~Num;
        else
            nu = o unsafely_as ~Number;
            new IntNum(nu#longValue());
        fi)
    elif o instanceof JsonArray then
        it = (o unsafely_as ~JsonArray)#iterator();
        ar = array [];
        (it#hasNext()) loop push ar (_fromJS it#next());
        (list ar) as ~Object;
    elif o instanceof JsonObject then
        ma = new HashMap();
        i = (o unsafely_as ~JsonObject)#toMap()#entrySet()#iterator();
        i#hasNext() loop
           (e = i#next() unsafely_as ~java.util.Map$Entry;
            value = _fromJS (e#getValue() unsafely_as 'a);
            if not nullptr? value then
                ma#put(string e#getKey(), value);
            fi);
        if ma#size() == 0 then
            emptyJS as ~Object;
        else
            new HashStruct(ma);
        fi
    else
        o
    fi);

    
fromJS object is ~JsonObject -> 'a =
    (_fromJS object) unsafely_as 'a;

fromJSArray ar is ~JsonArray -> list<'a> =
    (_fromJS ar) unsafely_as list<'a>;    


toHandler fn is ('a -> 'b) -> ~Handler = 
   (class IYetiHandler extends Handler
        void handle(Object ob)
            fn (ob unsafely_as 'a),
    end;
    new IYetiHandler());

toSimpleHandler fn is (() -> 'a) -> ~Handler =
    toHandler fn;

toWebsocketHandler fn is (~WebSocket -> 'a) -> ~Handler =
        toHandler fn;

toAsyncResultHandler fn is ((Some 'a | None ~Exception ) -> 'b) -> ~AsyncResultHandler =
       (class IYetiAsyncResultHandler extends AsyncResultHandler
            void handle(Object o)
                r = o unsafely_as ~AsyncResult;
                if (r is ~AsyncResult)#succeeded() then
                    fn (Some r#result)
                else
                    fn (None r#exception);
                fi,
        end;
        new IYetiAsyncResultHandler());

toTypedAsyncResultHandler tfn fn is (~Object -> 'a) -> ((Some 'a | None ~Exception ) -> 'b) -> ~AsyncResultHandler =
       (class IYetiAsyncResultHandler extends AsyncResultHandler
            void handle(Object o)
                r = o unsafely_as ~AsyncResult;
                if (r is ~AsyncResult)#succeeded() then
                   fn (Some (tfn r#result))
                else
                   fn (None r#exception);
                fi,
        end;
        new IYetiAsyncResultHandler());
        
toBufferHandler fn is (~Buffer -> 'a) -> ~Handler =
        toHandler fn;

    
toExceptionHandler fn is (~Exception -> 'a) -> ~Handler =
        toHandler fn;
        
toStringHandler fn is (string ->'a) -> ~Handler =
        toHandler fn;
        


runOnLoop vertx handler = 
    (vertx is ~Vertx)#runOnLoop(toHandler (handler is () -> ()));

setPeriodic vertx delay handler = 
    (vertx is ~Vertx)#setPeriodic(delay, toHandler (handler is number -> ()));

setTimer vertx delay handler =
    (vertx is ~Vertx)#setTimer(delay, toHandler (handler is number -> ()));



    

    
    
verticle runFn is ({vertx is ~Vertx, container is ~Container} -> ({vertx is ~Vertx, container is ~Container} -> 'a)) -> ( () -> ~Verticle) =
   (class IYetiVerticle extends Verticle 
        var stopFn = \(failWith "No stopfuntion assigned yet"),
        
        void start()
            stopFn := 
                runFn {vertx = this#getVertx(), container = this#getContainer()},
        void stop()
            stopFn {vertx = this#getVertx(), container = this#getContainer()},
    end;
    \(new IYetiVerticle() as ~Verticle));

 
deployModule container name config instances handler = 
    (container is ~Container)#deployModule(name is string, 
                                            toJS config, 
                                            instances is number, 
                                            toStringHandler handler);

deployVerticle container name config instances handler= 
    (container is ~Container)#deployVerticle(name is string, 
                                                toJS config, 
                                                instances is number, 
                                                toStringHandler handler);
    
config container = fromJS ((container is ~Container)#getConfig());


enviroment container = 
   (ret = [:];
    forJavaMap ((container is ~Container)#getEnv()) do key value: 
        ret.[string key] := string value;
    done;
    ret);


undeployModule container deploymentID handler =
    (container is ~Container)#undeployModule(deploymentID, 
                                    toHandler (handler is () -> ()));
    
undeployVerticle container deploymentID handler =
    (container is ~Container)#undeployVerticle(deploymentID, 
                                    toHandler (handler is () -> ()));

timeout vertx time fn = 
    (var handled = false;

    _ = setTimer vertx time do:
        if not handled then
            handled := true;
            fn (None "timeout")
        fi
    done;
    
    do arg:
        if not handled then
            handled := true;
            fn (Some arg);
        fi
    done);

typedef cbrType<a> = Some a | None ~Exception;
typedef cbfnType<a> = (cbrType<a> -> ()) -> ();

cbId v = do cb: cb v done;
cbBind fn cbfn cb = 
    cbfn \case of
        None ex: cb (None ex);
        Some v: (fn v) cb;
        esac;
cbFlatten cbfn cb = cbBind id;

cbMap fn cbfn cb =
    cbfn \case of
        None ex : cb (None ex);
        Some v : cb (Some (fn v));
        esac;

cbLift fn cb a=
    cb (fn a);
    
cbSeq cbfns cb =
    (var called = false;
     res = array [];
     for cbfns do c:
        c \case of
            None ex: 
                if not called then
                    called := true;
                    cb (None ex);
                    called := true;
                fi;
            Some v:
                if not called then
                    push res v;
                    if length res == length cbfns then
                        called := true;
                        cb (Some (list res));
                    fi
                fi
            esac;
    done);

cbStruTH = threadLocal none;

cbSet cbfn =
    (ctr = case cbStruTH.value of
            None _ : failWith "not in cbStru function";
            Some v : v;
           esac;
    ctr.starting();
    var hasReceived = false;
    var res = NotSet ();
    cbfn \case of
        None ex: 
            (res := None (ex is ~Exception);
             ctr.exception(ex));
        Some v: 
            (res := Some v;
            if not hasReceived then
                ctr.hasReceived();
                hasReceived := true
            fi);
        esac;
    \(res));    

cbStru inex cb =
    (var called = false;
     var requests = 0;
     var received = 0;
     var result = none;
     ctr = {
        starting () = 
            requests := requests + 1,
        exception ex =
            if not called then
                called := true;
                cb (None (ex is ~Exception));
            fi,
        hasReceived () =
            received := received + 1;
            if not called then
                case result of
                None _ : ();
                Some v: 
                    if received == requests then
                        called := true;
                        cb v;
                    fi;
                esac;
            fi,
    };
    try 
        cbStruTH.value := Some ctr;
        r = inex ();
        result := Some r;
        if not called and received == requests then
            called := true;
            cb r
        fi;
            
    catch Exception ex:
        if not called then
            called := true;
            cb (None ex);
        fi
    finally
        cbStruTH.value := none;
    yrt;
    ());

cbRun exfn =\case of
    None ex: exfn ex;
    Some (): ();
    esac;

(->) cbfn fn =  cbMap fn cbfn;
(->>) cbfn fn = cbBind fn cbfn;

bus = {
    toMessageHandler fn is (~Message -> 'a) -> ~Handler =
            toHandler fn,

    toJsonMessageHandler fn =
        (class YvertxMessageHandler extends Handler
            void handle(Object ob)
                msg = ob unsafely_as ~Message;
                _ = fn {message = msg,
                    handler = this as ~Handler,
                    get body () = fromJS (msg#body unsafely_as ~JsonObject),
                    get replyAddress () = string msg#replyAddress,
                    reply v = msg#reply(toJS v),
                    request v handler = 
                        msg#reply(toJS v, toJsonMessageHandler handler)
                   }
        end;
        new YvertxMessageHandler() as ~Handler),

    publish vertx address msg = 
        (vertx is ~Vertx)#eventBus()#publish(address is string, toJS msg),

    send vertx address msg =
        (vertx is ~Vertx)#eventBus()#send(address is string, toJS msg),
    request vertx address msg handler =   
        (vertx is ~Vertx)#eventBus()#send(address is string, toJS msg, 
                toJsonMessageHandler handler),
        
    register vertx address resultHandler handler =
        (vertx is ~Vertx)#eventBus()#registerHandler(address is string,
                                toJsonMessageHandler handler,
                                toAsyncResultHandler resultHandler),
        
    registerLocal vertx address handler =
        (vertx is ~Vertx)#eventBus()#registerLocalHandler(address is string,
                       toJsonMessageHandler handler),
            

    unregister vertx id handler resultHandler =
        (vertx is ~Vertx)#eventBus()#unregisterHandler(id is string, handler, 
                              toAsyncResultHandler resultHandler),
};

fsHelper = {
    closeAFile file handler =
        (file is ~AsyncFile)#close(toAsyncResultHandler handler),

    flushAFile file handler =
        (file is ~AsyncFile)#flush(toAsyncResultHandler handler),

    readAFile file buffer offset position length handler =
        (file is ~AsyncFile)#read(buffer is ~Buffer, offset is number,
                                  position is number,
                                  length is number,
                                  toTypedAsyncResultHandler 
                                    (unsafely_as ~Buffer) handler),

    writeAFile file buffer position handler =
        (file is ~AsyncFile)#write(buffer is ~Buffer, position is number,
                                   toAsyncResultHandler handler),
};

fileSystem vertx =
    (fs = (vertx is ~Vertx)#fileSystem();
    {
    fileSystem = fs,
    chmod path perms handler =
        fs#chmod(path is string, perms is string, 
                    toAsyncResultHandler handler),

    chmodDir path perms dirPerms handler =
        (fs)#chmod(path is string, perms is string, dirPerms is string,
                         toAsyncResultHandler handler),

    copy from to recursive handler =
        (fs)#copy(from is string, to is string, 
                         recursive is boolean, toAsyncResultHandler handler),

    createFile path perms handler =
        case perms of
        None _ :
            (fs)#createFile(path is string, toAsyncResultHandler handler);
        Some perm:
            (fs)#createFile(path, perm is string, 
                        toAsyncResultHandler handler);
        esac,

    delete path recursive handler =
        (fs)#delete(path is string, recursive is boolean, 
                    toAsyncResultHandler handler),

    exists path handler =
        (fs)#exists(path is string, 
                toTypedAsyncResultHandler (unsafely_as boolean) handler),
        
    fsProps path handler =
        (fs)#fsProps(path is string, 
                     toTypedAsyncResultHandler 
                        (unsafely_as ~FileSystemProps) handler),

    link link existing handler =
        (fs)#link(link is string, existing is string, 
                    toAsyncResultHandler handler),
     
    lprops path handler =
        (fs)#lprops(path is string, 
                    toTypedAsyncResultHandler 
                        (unsafely_as ~FileProps) handler),

    mkdir path perms createParents handler =
        case perms of
        None _ : 
            (fs)#mkdir(path is string, 
                       createParents is boolean, toAsyncResultHandler handler);
        Some perm:
            (fs)#mkdir(path is string, perm is string, 
                       createParents is boolean, toAsyncResultHandler handler);
        esac,

    move from to handler =
        (fs)#move(from is string, to is string, toAsyncResultHandler handler),

    props path handler =
        (fs)#props(path is string, 
                   toTypedAsyncResultHandler (unsafely_as ~FileProps) handler),
        
    readDir path filter handler =
       (mfn obj = map string (wrapArray ((obj is ~Object) 
                                    unsafely_as ~String[]));
        case filter of
        None _:
            (fs)#readDir(path is string, 
                         toTypedAsyncResultHandler mfn handler);
        Some fil:
            (fs)#readDir(path is string, 
                         fil is string, toTypedAsyncResultHandler mfn handler);
        esac),

    readFile path handler =
        (fs)#readFile(path is string, 
                      toTypedAsyncResultHandler (unsafely_as ~Buffer) handler),

    readSymlink path handler =
        (fs)#readSymlink(path is string, 
                         toTypedAsyncResultHandler 
                            (unsafely_as string) handler),
        
    symlink link existing handler =
        (fs)#symlink(link is string, existing is string, 
                     toAsyncResultHandler handler),

    truncate path len handler =
        (fs)#truncate(path is string, 
                      len is number, toAsyncResultHandler handler),

    unlink link handler =
        (fs)#unlink(link is string, toAsyncResultHandler handler),

    writeFile path data handler =
        (fs)#writeFile(path is string, 
                       data is ~Buffer, 
                       toAsyncResultHandler handler),

    open opts path handler =
       (var createNew = true;
        var flush = false;
        var read = true;
        var write = true;
        var perms = () as ~String;
        for opts do opt:
            case opt of
            CreateNew b : createNew := b;
            Read b: read := b;
            Write b: write := b;
            Flush b: flush := b;
            Perms s: perms := s;
            esac
        done;
        
        (fs)#open(path is string, perms, read, write, createNew, flush, 
                  toTypedAsyncResultHandler 
                        (unsafely_as ~AsyncFile) handler)),

    } with fsHelper);

_runTestsImpl tests resultO allResults vertx container =
    if empty? tests then
        f = allResults |> map do {name,result}:
            case result of
            Failure msg: Some {name, msg};
            _ : none;
            esac
            done
            |> catSome;
        ok = allResults |> map do {name,result}:
            case result of
            Success msg : Some {name, msg};
            _ : none;
            esac
            done
            |> catSome;
        exs = allResults |> map do {name,result}:
            case result of
            Exception ex: Some {name, msg = string ex};
            _ : none;
            esac
            done
            |> catSome;
        println "=========\nResults of runTest\n----------";               
        if length ok == 0 then
            println "\nno succesful results\n";
        else
            println "\nSuccesful results: \n";
            for ok do {name, msg}: println "[\(name)] : \(msg)"done;
        fi;

        if length f == 0 then
            println "\n---\nno failures\n";
        else
            println "\n---\nFailed results: \n"; 
            for f do {name, msg}: println "[\(name)] : \(msg)"done;
        fi;

        if length exs == 0 then
            println "\n---\nno exceptions\n";
        else
            println "\n---\nException results: \n"; 
            for exs do {name, msg}: println "[\(name)] : \n\(msg)"done;
        fi;

        println "---\ntotal:\n";
        if length f > 0 or length exs > 0 then
            print "Failure :";
        else
            print "Ok :";
        fi;
        println "total runs: \(length allResults); ok: \(length ok); failures: \(length f); exceptions: \(length exs)";
        
        (container is ~Container)#exit();
    else
        case resultO of
        None _ : 
            ({name,test} = head tests;
            res= {
                name is string,
                var result = none,
                var stopTime = 0,
                setTimeout tm =
                    stopTime := System#currentTimeMillis() + tm,

                assert msg suc=
                    if suc then
                        case result of
                        Failure msg: ();
                        _ : result := Success (msg is string);
                        esac
                    else
                        result := Failure msg;
                        stopTime := 0;
                    fi,
                assure msg suc =
                    (assert msg suc;
                    stopTime := 0);
            };
            res.setTimeout 1000;
            try
                test res;
                _runTestsImpl tests (Some res) allResults vertx container;
            catch Exception ex:
               container#getLogger()#error("test: [\(name)]",ex);
               //run next tests but with bad result
               _runTestsImpl (tail tests)
                             none
                             ({name, result = Exception ex} 
                                :: allResults)
                             vertx
                             container;
            yrt);
        Some res:
            if System#currentTimeMillis() < res.stopTime then
                runOnLoop vertx 
                    \(_runTestsImpl tests resultO allResults vertx container)
            else
                case res.result of
                Success msg : _runTestsImpl (tail tests)
                                  none
                                  ({name = res.name, result = Success msg} 
                                    :: allResults)
                                  vertx
                                  container;
                None _ :
                    (msg = "timed out";
                    container#getLogger()#error("failure in \(res.name): \(msg)");
                    _runTestsImpl (tail tests)
                                  none
                                  ({name = res.name, result = Failure msg} 
                                    :: allResults)
                                  vertx
                                  container);
                Failure msg : 
                    (container#getLogger()#error("failure in \(res.name): \(msg)");
                    _runTestsImpl (tail tests)
                                  none
                                  ({name = res.name, result = Failure msg} 
                                    :: allResults)
                                  vertx
                                  container);
                esac
            fi
        esac;
    fi;

 
{
    get context () =  Context#getContext(),
    addCloseHook key fn = 
        Context#getContext()#putCloseHook(key is string, runnable fn),
    executeOnWorker fn = 
        Context#getContext()#executeOnWorker(runnable fn),
    

    toHandler, 
    toSimpleHandler,
    toWebsocketHandler, 
    toAsyncResultHandler, 
    toExceptionHandler,
    toBufferHandler,
    
    toJS, 
    toJSArray,
    fromJS, 
    fromJSArray,
    emptyJS, 
    
    verticle,
    newBuffer size = new Buffer(size is number),
    newStringBuffer str = new Buffer(str is string),
    newEncodedBuffer str encoding = 
        new Buffer(str is string, encoding is string),
    
    createPump readStream writeStream = 
        Pump#createPump(readStream, writeStream), 

    runOnLoop, 
    setPeriodic, 
    setTimer, 
    logger container = (container is ~Container)#getLogger(),
    
    sharedData vertx = 
        (vertx is ~Vertx)#sharedData(),
    
    

    deployModule, 
    deployVerticle, 
    config, 
    enviroment,
    undeployModule, 
    undeployVerticle,

    helper = {
        hostAndPort hostPort =
           (i = strIndexOf hostPort ":" 0;
            if i < 0 then 
                {port = 80, host = hostPort}
            else
               {host = strLeft hostPort i,
                port = int (number (strRight hostPort (i+1)))}
            fi),
        toTypedAsyncResultHandler
    } with fsHelper,
    
    bus,
    fileSystem,

    publish = bus.publish,
    send = bus.send,
    
    obj x = x unsafely_as ~Object,

    timeout,

    runTests vertx container tests =
        (ts = mapHash do name test: {name,test} done tests;
        println "start testing: tests \(ts |> map (.name))";
        _runTestsImpl ts none [] vertx container),

        
    cbId,
    cbBind,
    cbFlatten,
    cbMap,
    cbLift,
    cbSeq,
    cbSet,
    cbStru,
}     
    
